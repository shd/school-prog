Язык Окамль. 

Краткая памятка.

1. Программа на языке Окамль состоит из выражений и 


Определение функций.

Формально функции определяются так:

let <имя функции> <формальный параметр 1> ... <формальный параметр n> = <тело функции>

Не думаю, что от этого текста стало понятнее, что тут происходит, поэтому давайте 
разберём лучше неформальную суть вопроса.

Часто бывает так, что некоторое действие (вычисление, формулу) необходимо повторить
много раз. Например, в программе определены переменные a и b, и нам нужно напечатать 
на экране их сумму. Для этого можно предложить следующий умеренно простой код:

let a = 10;; let b = 15;;

print_int a; print_string " + "; print_int b; 
print_string " = "; print_int (a+b); print_string "\n";;

Однако, наша жизнь значительно усложнится, если нам потребуется напечатать результат
вычисления четырёх действий: суммы, разности, умножения и деления. Нам потребуется
повторить этот код ещё три раза:

let a = 10;; let b = 15;;

print_int a; print_string " + "; print_int b; 
print_string " = "; print_int (a+b); print_string "\n";;
print_int a; print_string " - "; print_int b; 
print_string " = "; print_int (a-b); print_string "\n";;
print_int a; print_string " * "; print_int b; 
print_string " = "; print_int (a*b); print_string "\n";;
print_int a; print_string " / "; print_int b; 
print_string " = "; print_int (a/b); print_string "\n";;

В этом примере разобраться уже довольно тяжело. Его тяжеловесность и сложность
наглядно показывает, что тут требуется какое-то более изящное решение.

Однако, мы видим, что содержательно ничем эти скопированные куски кода не 
отличаются друг от друга. Отличаются они только двумя местами: 
строчкой, которая печатается между a и b, и операцией, которая выполняется 
при печати результата. Весь остальной текст совершенно одинаков.
Хорошо было бы написать этот одинаковый текст один раз, а указывать только 
изменяющуюся часть.

Собственно, давайте заменим эти различающиеся места на пустые квадратики:

print_int a; print_string []; print_int b; 
print_string " = "; print_int []; print_string "\n";;

Если бы вы изучали программирование в первом классе, то можно было бы предложить 
рабочую тетрадь с упражнением: впишите правильные строку и знак операции в указанные
квадратики. Но мы уже повзрослее, поэтому давайте попросим это делать 
компилятор за нас.

Для этого определим функцию print_expr:

let print_expr str res = 
  print_int a; print_string str; print_int b; 
  print_string " = "; print_int res; print_string "\n";;

Заметьте: всё, в целом, осталось на месте, только первый квадратик превратился в
str, а второй --- в res. Ну да, и ещё появилась первая строчка, которая:
-- даёт название всему шаблону с квадратиками (print_expr);
-- даёт название квадратикам (str и res). 

Эти квадратики (str и res) по-учёному называются формальными параметрами. Часто 
вместо такого длинного названия говорят кратко параметр или аргумент.

Однако, определить функцию --- это только половина дела, ещё её нужно вызвать:
т.е. заполнить пустые квадратики реальными значениями (или, иначе, указать
фактические параметры).

Делается это традиционно:

print_expr " + " (a+b);;

Здесь мы берём функцию print_expr, и в её теле (т.е. тексте после равенства)
заменяем все str на " + ", а res --- на (a+b).

Весь же код в итоге начинает выглядеть как-то так:

let a = 10;; let b = 15;;

let print_expr str res = 
  print_int a; print_string str; print_int b; 
  print_string " = "; print_int res; print_string "\n";;
print_expr " + " (a+b);;
print_expr " - " (a-b);;
print_expr " * " (a*b);;
print_expr " / " (a/b);;

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Результат функции.

Однако, функции -- конструкция более мощная, чем только конструкция для повторения
действий. 


---------------------------------------------

Графическая библиотека.

Graphics;;

Начало работы:

Graphics.open_graph "" -- эта команда открывает на экране графическое окно.

Если дать программе отработать, то результат мы не увидим: компьютер работает быстро,
а всё, что мы нарисовали в этом окне, исчезнет сразу же после конца работы программы.
Надо каким-то образом вычисление приостановить. Это можно сделать с помощью функции

Graphics.read_key ();;

Она ждёт нажатия клавиши пользователем:

let _ = Graphics.read_key ();;

---------------------------------------------------

Graphics.moveto 100 100;;
Graphics.lineto 200 200;;


Различного здесь -- только координаты. Было бы здорово, если бы мы могли не копировать
эти строки пять раз, а указать только отличия этих вызовов.

Это легко сделать с помощью функций.
Определим функцию line:

let line a b c d = Graphics.moveto a b; Graphics.lineto c d;;

Тогда любой вызов line будет приводить к вызову moveto, а затем lineto:

line 10 100 10 300;;


Квадрат -- начиная с координат (a,b):
a,b -> a+100,b -> a+100,b+100 -> a,b+100 -> a,b

