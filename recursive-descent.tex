\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{bnf}
\usepackage{tikz}
\usepackage[margin=2cm]{geometry}
\usetikzlibrary{arrows,backgrounds,patterns,matrix,shapes,fit,calc,shadows,plotmarks}
\usepackage{enumerate}
\usepackage{proof}
\usepackage{amsthm}
\begin{document}

\theoremstyle{definition}
\newtheorem{definition}{Определение}[section]

\title{Алгоритм рекурсивного спуска: краткое введение}
\author{Д.Г. Штукенберг, ЛНМО}

\maketitle

\section{Грамматика}

\begin{definition} Грамматикой называется упорядоченная четвёрка 
$\langle A_\textrm{н}, A_\textrm{т}, R, S \rangle$, в которой указаны:
\begin{enumerate}
\item два непересекающихся алфавита (терминальных
$A_\textrm{т}$ и нетерминальных $A_\textrm{н}$ символов);
\item множество правил $R$ вида 
$$\alpha\rightarrow\beta$$ где $\alpha$ и $\beta$ --- строки из алфавита
$A_\textrm{н} \cup A_\textrm{т}$, причём хотя бы один символ из $\alpha$ --- 
нетерминальный;
\item начальный символ $S \in A_\textrm{н}$.
\end{enumerate}
\end{definition}

\noindent В данной теме мы будем рассматривать только бесконтекстные грамматики: то есть,
все правила имеют следующий вид: $$x \rightarrow \beta$$
где $x \in A_\textrm{н}$, то есть слева от стрелки всегда указан ровно один символ,
и этот символ --- нетерминальный.

Будем говорить, что строка $\alpha$ получается из строки $\beta$ применением
правила $x \rightarrow \sigma$, если в строку $\beta$ входит символ $x$,
и замена одного из его вхождений на $\sigma$ даёт $\alpha$.

Например, пусть $A_\textrm{н} = \{(, )\}$ (символы круглых скобок),
а $A_\textrm{т} = \{X\}$ (большая буква $X$).
И пусть некоторое правило имеет вид
\begin{bnf}\begin{eqnarray*}
X &->& (X)X
\end{eqnarray*}\end{bnf}
Тогда в строке $(X)X$ это правило можно применить двумя способами: заменив 
первое либо второе вхождение $X$:

\vspace{0.2cm}\begin{tabular}{cc}
Заменяемое вхождение (подчёркнуто) & результат подстановки\\
\hline
$(\underline{X})X$ & $((X)X)X$ \\
$(X)\underline{X}$ & $(X)(X)X$
\end{tabular}\vspace{0.2cm}

Делать замены можно многократно, например, 
$(X)(X)X$ может быть получена из строки $X$ за два применения данного правила:

$$\underline{X} \Rightarrow (X)\underline{X} \Rightarrow (X)(X)X $$

Пусть теперь заданы два правила (напомним, что через $\varepsilon$ мы обозначаем пустую строку):
\begin{bnf}\begin{eqnarray*}
X &->& (X)X\\
X &->& \varepsilon
\end{eqnarray*}\end{bnf}%
С их помощью теперь мы можем построить строку, содержащую любую правильную скобочную
запись. Например, за 9 подстановок мы получим строку $()(())()$:

$$\underline{X} \Rightarrow (X)\underline{X} \Rightarrow (X)(X)\underline{X} 
\Rightarrow (X)(X)(X)\underline{X} \Rightarrow$$
$$\Rightarrow (X)(\underline{X})(X) \Rightarrow (X)((\underline{X})X)(X) 
\Rightarrow (X)(()\underline{X})(X) \Rightarrow (\underline{X})(())(X) \Rightarrow$$
$$\Rightarrow ()(())(\underline{X}) \Rightarrow ()(())()$$

Что более интересно, никакие неправильные скобочные записи с помощью этих
правил быть построены не могут.

В итоге мы приходим к определению:
\begin{definition} Множество строк $\mathcal{L}$ задаётся некоторой грамматикой, если:
\begin{enumerate}
\item любая строка из него может быть получена из начального символа путём 
последовательного применения правил грамматики;
\item никакие другие строки не могут быть получены таким образом.
\end{enumerate}
\end{definition}

\subsection{Запись грамматик: сокращения}

Часто бывает так, что мы имеем более одного правила для нетерминала. 
В этом случае мы будем использовать скобки и знак вертикальной черты (<<альтернатива>>).
Например, грамматику 
\begin{bnf}\begin{eqnarray*}
N &->& 0N\\
N &->& 1N\\
N &->& 2N\\
N &->& 3N\\
N &->& \varepsilon
\end{eqnarray*}\end{bnf}
мы могли бы переписать так:
\begin{bnf}\begin{eqnarray*}
N &->& (0|1|2|3) N
\end{eqnarray*}\end{bnf}

В общем же случае запись выглядит так:

\begin{bnf}\begin{eqnarray*}
Z &->& \gamma (\alpha_1 | \alpha_2 | \dots | \alpha_n) \delta
\end{eqnarray*}\end{bnf}

Данная запись означает, что нетерминал $Z$ может быть преобразован в строку
вида $\gamma\alpha_i\delta$: мы указали общие начальные и конечные 
части получающейся строки ($\gamma$ и $\delta$), а для середины перечислили возможные варианты
($\alpha_1$, $\alpha_2$,..., $\alpha_n$).

Такая запись удобна, но, поскольку скобки и вертикальные чёрточки могут быть и 
терминальными символами, надо быть внимательным.
Чтобы исключить ошибки, мы будем брать терминальные символы в кавычки и/или выделять 
их шрифтом. Например, грамматику для правильных скобочных записей из прошлого раздела 
мы будем записывать так:

\begin{bnf}\begin{eqnarray*}
X &->& ('\texttt{(}' X '\texttt{)}' X) | \varepsilon
\end{eqnarray*}\end{bnf}

\section{Терминалы и нетерминалы в реальных строках}
Терминальные символы увидеть просто, а вот что соответствует 
в реальных строках нетерминальным символам? Рассмотрим грамматику:

\begin{bnf}\begin{eqnarray*}
S &->& ('+'|'-') B\\
B &->& '1' C '.' C\\
C &->& ((0 | 1) C) | \varepsilon
\end{eqnarray*}\end{bnf}

Рассмотрим строку \verb!+10.01!, данная строка может быть порождена
данной грамматикой, что следует из дерева разбора для неё:

\begin{center}\tikz{
\node (S) at (-1,5) {$S$};
\node (P) at (-3,4) {\verb!+!};
\node (B) at (1,4) {$B$};
\draw[->] (S) -- (P); \draw[->] (S) -- (B);
\node (N1) at (-2,3) {\verb!1!};
\node (C1) at (0,3) {$C$};
\node (D1) at (2,3) {\verb!.!};
\node (C2) at (4,3) {$C$};
\draw[->] (B) -- (N1);
\draw[->] (B) -- (C1);
\draw[->] (B) -- (D1);
\draw[->] (B) -- (C2);

\node (Z5) at (-0.8,2) {\verb!0!};
\node (C5) at (0.8,2) {$C$};
\node (E5) at (0.8,1) {$\varepsilon$};
\draw[->] (C1) -- (Z5);
\draw[->] (C1) -- (C5);
\draw[->] (C5) -- (E5);

\node (Z6) at (3.2,2) {\verb!0!};
\node (C6) at (4.8,2) {$C$};
\draw[->] (C2) -- (Z6);
\draw[->] (C2) -- (C6);

\node (O7) at (4,1) {\verb!1!};
\node (C7) at (5.6,1) {$C$};
\node (E7) at (5.6,0) {$\varepsilon$};
\draw[->] (C6) -- (O7);
\draw[->] (C6) -- (C7);
\draw[->] (C7) -- (E7);
}\end{center}

Терминальным символам в этом дереве разбора соответствуют листья,
а вот нетерминальным символам соответствует сразу несколько 
листьев: скажем, нетерминалу $B$ соответствует почти весь текст
(кроме первого символа \verb!+!), а у нетерминала $C$ есть пять
подстрок, соответствующих ему:

  $$\texttt{+1}\underbrace{\texttt{0}}_\textit{№1}\texttt{.01},\quad
    \texttt{+10}\underbrace{\texttt{}}_\textit{№2}\texttt{.01},\quad
    \texttt{+10.}\underbrace{\texttt{01}}_\textit{№3}\texttt{},\quad
    \texttt{+10.0}\underbrace{\texttt{1}}_\textit{№4}\texttt{},\quad
    \texttt{+10.01}\underbrace{\texttt{}}_\textit{№5}\texttt{}$$

Заметьте, что варианты прочтения №2 и №5 пусты --- данные нетерминалы в дереве
разбора раскрылись в пустую подстроку.

\section{Разбор текста}

Если даны исходный нетерминальный символ и последовательность применения
правил, мы легко получим итоговую строку. 
Обратная же задача --- задача \emph{разбора текста} --- состоит
в угадывании того, какие правила нужно применить, чтобы получить данную
строку. 

То есть, если мы по каждому символу строки можем указать, какие узлы
дерева разбора его содержат, то мы решаем задачу разбора строки.

Если дан символ в строке, 
Проверить, что в строке \verb!s! в позиции \verb!n! находится терминальный символ
\verb!c! просто --- достаточно сравнить реальный символ и ожидаемый:
\begin{verbatim}
if s.[n] = c then "Подходящий символ" 
             else "Неправильный символ";;
\end{verbatim}
Давайте научимся сопоставлять участкам строки нетерминальные символы. 

Напишем для каждого нетерминального символа функцию, предназначенную
для разбора соответствующего нетерминала: функцию, умеющую отвечать на
вопрос: <<где заканчивается нетерминальный символ, если он начинается
в данной позиции?>>. При необходимости мы можем научить эту функцию
в том числе и строить дерево разбора.

Такая функция берёт на вход целое число --- некоторую позицию в строке, 
и возвращает другое целое число --- первую позицию \emph{после} 
разбираемого ею нетерминального символа. В случае, если есть несколько 
способов прочесть нетерминал, функция ведёт себя <<жадно>> и выбирает 
самое длинное прочтение.

\begin{verbatim}
parse_n: int -> int
\end{verbatim}

Помимо новой позиции, функция может возвращать что-то ещё, например,
построенное синтаксическое дерево.

\begin{verbatim}
parse_n: int -> tree * int
\end{verbatim}

Если функция вызвана в позиции, начиная с которой данной нетерминальный
символ прочесть нельзя, поведение её может быть сколь угодно странным.

\subsection{Пример}

Напомним, если рассмотреть дерево из прошлого раздела, нетерминал $C$ 
в дереве разбора присутствует в пяти местах, соответственно, соответствует
ему пять подстрок. Функция \verb!parse_c! в соответствии с соглашением
должна по началу каждой такой подстроки находить её конец:

\begin{tabular}{cccc}
№ &Подстрока & интервал её индексов & результат вызова \verb!parse_c!\\
\hline
1 & $\texttt{+1}\underline{\texttt{0}}\texttt{.01}$ & $[2,3)$ & \verb!parse_c 2 = 3! \\
2 & $\texttt{+10}\underline{\texttt{}}\texttt{.01}$ & $[3,3)$ & \verb!parse_c 3 = 3! \\
3 & $\texttt{+10.}\underline{\texttt{01}}\texttt{}$ & $[4,6)$ & \verb!parse_c 4 = 6! \\
4 & $\texttt{+10.0}\underline{\texttt{1}}\texttt{}$ & $[5,6)$ & \verb!parse_c 5 = 6! \\
5 & $\texttt{+10.01}\underline{\texttt{}}\texttt{}$ & $[6,6)$ & \verb!parse_c 6 = 6!
\end{tabular}

\subsection{Как реализовать разбор нетерминала}

Начнём с функции \verb!parse_c!. Рассмотрим все правила грамматики, преобразующие
нетерминал $C$:

\begin{bnf}\begin{eqnarray*}
C &->& ((0 | 1) C) | \varepsilon
\end{eqnarray*}\end{bnf}

Рассмотрим эти правила: нетерминал $C$ --- это:
\begin{enumerate}
\item либо символ 0 или 1, за которым снова идёт нетерминал $C$;
\item либо пустая строка.
\end{enumerate}
Значит, при разборе нетерминала надо разобрать эти два случая:
\begin{enumerate}
\item либо в данной позиции находится 0 или 1 --- тогда надо вернуть результат 
рекурсивного вызова $C$ со следующей позиции;
\item либо в данной позиции что-то другое --- тогда надо вернуться из вызова сразу.
\end{enumerate}

Из этого сразу получается требуемый код (здесь \verb!str! --- это строка,
которую мы разбираем, она известна из контекста):

\begin{verbatim}
let rec parse_c pos =
    if str.[pos] = '0' || str.[pos] = '1' then parse_c (pos + 1)
    else pos;;
\end{verbatim}

\subsection{Реализация разборов остальных нетерминалов}

Теперь рассмотрим функцию \verb!parse_b!: 
\begin{bnf}\begin{eqnarray*}
B &->& '1' C '.' C\\
\end{eqnarray*}\end{bnf}

Надо убедиться, что первый символ --- это $1$, затем идёт нетерминал $C$, затем точка, 
а затем --- ещё раз $C$. Как мы уже знаем, проверка терминалов 1 и точки может быть
сделана прямо, а разбор нетерминала $C$ выполнит вызов функции \verb!parse_c!:

\begin{verbatim}
let rec parse_b pos =
    if str.[pos] <> '1' then failwith "ожидалось 1";
    let pos1 = parse_c (pos + 1) in
    if str.[pos1] <> '.' then failwith "ожидалась точка";
    parse_c (pos1 + 1);;
\end{verbatim}

Обратите внимание на работу с позициями строки: раз начальный символ 1 находится
в позиции \verb!pos!, то первый нетерминал $C$ начинается в позиции \verb!pos+1!,
точка находится в первой позиции после $C$ (эту позицию возвращает \verb!parse_c!),
и второй нетерминал $C$ --- в позиции сразу за точкой.

Нам осталась грамматика и функция для $S$:
\begin{bnf}\begin{eqnarray*}
S &->& ('+'|'-') B
\end{eqnarray*}\end{bnf}%
\noindent И осталось написать функцию для него:
\begin{verbatim}
let rec parse_s pos =
    if str.[pos] = '+' || str.[pos] = '-' then parse_b (pos + 1)
    else failwith "Ожидался символ '+' или '-'"
\end{verbatim}

\subsection{Реализация разбора в целом}

Нам осталось организовать разбор --- соединить все функции вместе и добавить к ним
<<обвязку>>: сформировать контекст (строка \verb!str! где-то должна быть определена),
сделать правильный вызов разбора начального нетерминала (в нашем примере это $S$) и
правильно проанализировать результат. В данном разделе мы напишем функцию,
проверяющую, является ли строка на входе построенной по указанной грамматике.

Мы сделаем это с помощью \emph{взаимной рекурсии} --- особой формы рекурсии, где
несколько функций вызывают друг друга в хаотичном порядке. Такие функции должны быть
определены рядом с помощью ключевого слова \verb!and!:

\begin{verbatim}
let rec is_odd n = 
    if n > 0 then is_even (n-1)
    else false
and is_even n =
    if n > 0 then is_odd (n-1)
    else true;;
\end{verbatim}

\noindent Приведённые выше два определения взаимно-рекурсивных функций позволяют определить чётность
числа: убедитесь, что \verb!is_odd 4 = false! и \verb!is_even 2 = true!.

Итак, определим главную функцию \verb!parse! для <<разбора вообще>>, эта функция будет содержать 
в себе определения всех функций для разбора нетерминалов и проверки результата работы:

\begin{verbatim}
let parse s =
    let str = s ^ ";" in

    let rec parse_c pos = ... in
    and parse_b pos = ... in
    and parse_s pos = ... in

    parse_s pos = String.length str - 1;;
\end{verbatim}

Обратим внимание на несколько важных особенностей функции \verb!parse!:
\begin{enumerate}
\item Переменная \verb!str! --- которую используют все функции, разбирающие
отдельные нетерминалы --- это входная строка, к которой добавлен знак точки с
запятой в конце. Данный дополнительный символ служит ограничителем для разбора.

В самом деле, если разбор дошёл до конца строки, но в строке нет никакого ограничителя
(в рассматриваемом примере для второго нетерминала $C$ такого ограничителя нет), 
мы будем двигаться вперёд, пока не обратимся к символу за концом строки --- 
и в результате не получим ошибку.

Можно решать эту проблему добавлением во все функции для нетерминалов проверок 
--- но более простым решением является добавление в конец строки символа, заведомо
отсутствующего в грамматике. Тогда рекурсивный спуск, дойдя до этого символа,
неизбежно остановится: проследите по функциям, что это будет именно так.

\item Мы должны убедиться, что строка действительно полностью разобрана: вполне
возможно, во входной строке есть ошибочные символы, из-за которых разбор остановится
раньше. Для этого мы вызовем функцию для начального нетерминала $S$ и убедимся, что
она остановилась на последнем символе (на точке с запятой). 

\item Если же на вход программе дадут строку, не содержащую каких-то требуемых
грамматикой символов (например, \verb!"+10"!), то разбор, наткнувшись на неподходящий
символ (в крайнем случае --- на ограничивающую строку точку с запятой), закончит
свою работу с исключением.
\end{enumerate}

%\section{Полезный разбор}
%
%Рассмотренный выше пример позволяет проверить строку на соответствие грамматике,
%но ни на что больше не годится. А как бы мы могли 

\end{document}