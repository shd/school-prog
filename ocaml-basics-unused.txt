\subsection{Выражения, константы}

Было бы непонятно, зачем нужен язык программирования, если в нем нельзя
производить никаких вычислений. Давайте научимся это делать.

Особенностью языка Окамль является то, что для значений каждого типа 
существует свой набор операций. Это кажется обычным, если дело касается
строчек и чисел: числа не имеет смысл соединять вместе, а строчки умножать
или делить. Но в Окамле различие есть также и между операциями для целых
и для плавающих чисел.

Рассмотрим два выражения:

let x = (12 + 24) * (42 / 42) - 8;;

Читатель, наверное, без труда вычислит результат этого выражения (28), и
вычислив его, (неформально) познакомится с правилами записи арифметических
выражений для целых чисел.

let y = (12. +. 24.) *. (42. /. 42.) -. 8.;;

Результат у него такой же (28.), но обилие точек требует объяснения: 
дело в том, что все арифметические операции для плавающих чисел имеют в Окамле 
другие обозначения. При этом, если вы примените целочисленную операцию к 
плавающим числам, или плавающую операцию к целым, возникнет ошибка.
"+." - это имя операции сложения чисел с плавающией точкой. После имен 
нетерминальных символов, таких как <плавающее-число>, это не должно нас 
смущать.

Читатель, возможно, спросит - а как же деление? Неужели при вычислении
12/5 не возникает плавающего числа? В том и идея разных имен для схожих
операций, что схожие они только для стороннего наблюдателя. Целочисленное 
деление выдает частное с отброшенной дробной частью, и результатом 12/5 
будет 2.

По сравнению с арифметическими выражениями, со строками все проще:
для них мы пока рассмотрим только одну операцию - конкатенацию (или, 
по-русски, соединение строк).

let str = "Здравствуй," ^ " мир!";;

Эта операция создаст константу "Здравствуй, мир!".

\subsection{Операции ввода с клавиатуры}

Компьютер не будет особенно ни на что пригоден, если не сможет получать
данные из внешнего мира. Самое простое - получать данные от пользователя,
с клавиатуры.

Чтение значений, как вы уже догадались, производится различными функциями,
и каждая функция читает свой тип значений.

let a = read_float ();;
let b = read_int ();;
let c = read_line ();;

Скобки () после имени функции нужны, чтобы указать фиктивный параметр для 
вызова функции. Без них компилятор не сможет разобраться, идет ли речь о
вызове функции или только об ее имени. Не забывайте их!
   
Обратите внимание на третий случай - на чтение строчки; функция называется
не read_string, а read_line. Такое название связано с тем, что не существует
никакого естественного ограничения для строчки; скажем, если после числа
появился пробел - значит, число на этом закончилось. Но этого про строчку
не скажешь. Поэтому функции read_string в общем случае не сделать. Но можно
выбрать какой-нибудь ограничитель и сделать функцию, читающую до него.
Поэтому и появилось название read_line - функция читает до нажатия клавиши
Enter, т.е. целиком строку (line) до ее окончания. 

Заметим, что в английском языке используется два разных слова: line - строка 
текста (на экране, на листе бумаги) и string - строка как тип данных, еще это 
слово значит последовательность, веревку, струну, можно представить себе буквы, 
нанизанные на нитку, как бусы; по-русски же оба слова в применении к 
программированию переводятся как строка. Мы будем разграничивать эти значения, 
используя слово строка для line и строчка для string.

Пример.

print\_string "Здравствуйте, как вас зовут? ";;
let name = read_line ();;
print\_string "Приятно познакомиться, ";;
print\_string name;;
print\_string ".\n";;

Эта программа просит ввести имя с клавиатуры и печатает сообщение
с использованием этого имени.

Упражнения:

7.1. Напишите программу для вычисления площади круга по вводимому с клавиатуры
     радиусу. Напишите вариант для целых и для плавающих чисел.

7.2. Напишите программу для решения линейного уравнения a*x + b = c.
     С клавиатуры вводятся параметры a,b и c, программа должна печатать x.
     Числа a,b и c - плавающие.

7.3. 

\subsection{Функции}

Мы уже довольно давно пользуемся функциями, настала пора уделить им
больше времени.

Существует математические определения функции, как отображения, ставящего
в соответствие каждому элементу одного множества (называемого множеством
отправления), ровно один элемент другого множества (называемого множеством
прибытия).

Это определение сохраняет некоторый смысл и в случае функциональных 
языков программирования - скажем, функция sqrt, вычисляющая квадратный корень,
действительно очень близка к математическому определению; такая функция
называется чистой. Но существует и отличие. В языках программирования 
возникает понятие побочного эффекта -- любое действие может, помимо 
вычисления требуемого значения, как-то повлиять на остальной мир.

Например, как вы думаете, функция format_hard_disk_drive, берущая в качестве 
аргумента целое число и возвращающая строчку "винчестер отформатирован" - 
действительно ли это только функция из множества целых чисел в одноэлементное 
множество? Впрочем и другие, менее разрушительные функции, также могут
иметь побочный эффект. Например, функция печати строки на экране - ценность ее
только в побочном эффекте.

Поэтому мы будем придерживаться другого, более утилитарного, взгляда на 
функцию. Функция - это именованное выражение, описываемое с помощью следующей 
конструкции:

<описание-функции> ::= 
  let [rec] <идентификатор-функции> 
      (<идентификатор-формального-параметра>+ | ()) = 
    <выражение>;; 

Отличие от описания константы - наличие формальных параметров, указываемых
через пробел перед знаком равенства.

Идентификаторы функции и формального параметра строятся по тем же правилам,
что и идентификаторы констант - поскольку это суть такие же константы,
просто чуть по-другому описываемые.

Пример:
let average a b = (a+b)/2;;

Эта функция берет два аргумента и возвращает их полусумму. Константы a и b
называются формальными параметрами - формальными потому, что при вызове
функции вместо них подставляются фактические параметры:

print\_int (average 3 9);;

Вычисление значения выражения мы можем представить так: вместо букв a и b 
в описании функции подставляются числа 3 и 9:

let average 3 9 = (3+9)/2;;
 
Выражение справа от равенства (тело) функции вычисляется и результат (6)
подставляется в место вызова функции:

print\_int (6);;

В тех случаях, когда функция не имеет параметров, мы должны по правилам
языка Окамль указать какой-нибудь фиктивный параметр - иначе функция
превратится в константу. Обычно такое нужно из-за побочного эффекта
функции, поскольку чистая функция, не зависящая от аргументов, как раз
константа и есть.

Существует специальный тип, который используется для указания
фиктивного значения там, где оно нужно - это тип unit. Он имеет ровно 
одно значение, записываемого () - это значение ранее нам уже встречалось.

Для примера покажем, как описать функцию, печатающую приветствие:

let print\_hello () = print\_string "Привет!";;

Здесь значение () исполняет роль формального формального параметра.
Вызов выглядит уже знакомо:

print\_hello ();;

Здесь значение () исполняет роль формального фактического параметра.

\subsection{Возвращать или печатать?}

Существенным вопросом, касающимся функций, является вопрос о результате
их работы. Предположим, у нас стоит задача написать функцию, вычисляющую
площадь треугольника.

У нас есть 2 варианта:
let triangle_area1 a h = a *. h /. 2;;
let triangle_arge2 a h = print\_float (a *. h /. 2);;

Первый вариант функции возвращает значение площади. Функция triangle_area1
берет 2 аргумента с плавающей точкой и возвращает плавающий результат.
Второй же вариант печатает площадь треугольника на экране - а в вызвавшее
функцию выражение возвращает значение типа unit. 

Не смотря на то, что разница между этими вариантами может казаться 
незначительной -- площадь же все равно вычисляется -- тем не менее, 
в чуть более сложных задачах этот вопрос может стать принципиальным.

Дело в том, что значение функции может быть использовано в дальнейших 
вычислениях, и тем самым появляется много дополнительных случаев для 
ее применения. Функция, печатающая вычисленное значение на экране, такой 
возможности лишена. Поэтому везде в задачах, где явно не указано иное, 
предполагается, что от вас требуется написание функции, к которой при 
необходимости прилагается отдельный код, печатающий ее результат:

let a = read_float ();;
let h = read_float ();;
let triangle_area a h = a *. h /. 2;;
print\_float (triangle_area a h);;

Совокупность подобных правил написания программ в тех случаях, когда есть 
много возможных способов написать тот или иной код, называется стилем.
Конкретный стиль может быть разным в зависимости от назначения и особенностей
создаваемого программного обеспечения. В тех случаях, когда программы 
становятся реально большими (сотни тысяч и миллионы строк кода), 
следование стилю существенно упрощает работу с проектом, а отступления от
стиля могут обойтись реально дорого. 

Мы далее познакомимся и с другими правилами, обычно определяемыми стилем 
программирования.

\subsection{Условное выражение}

Вернемся к одной из задач: будем решать линейное уравнение вида a*x + b = c.

Нетрудно видеть, что это уравнение почти всегда имеет ровно одно решение,
кроме случая, когда a = 0. В этом случае, в зависимости от констант b и c,
уравнение либо имеет бесконечно много решений, либо ни одного.

Надо как-то выделить этот случай, поскольку применение классической формулы
x = (c - b)/a даст деление на 0, что приведет к ошибке выполнения программы.

Для этого как раз нам и пригодится условное выражение. 

print\_string "x:\n";;
if a <> 0. then 
  print\_float ((c -. b) /. a)
else 
  print\_string "либо ни одного, либо бесконечно много";;

Заметьте, мы пользуемся для сравнения константы a с 0 операцией, которую еще не
проходили.

Операций для сравнения значений существует 6:
=  равно     1 = 1
<> не равно  1 <> 2
>  больше    2 > 1
<  меньше    1 < 2
>= больше или равно 1 >= 1
<= меньше или равно 3 <= 7

Каждая операция выдает значение ранее нам не встечавшегося булевского типа.
Существует всего два значения булевского типа - true (истина) и false (ложь).
Например, все сравнения из таблицы выдадут значения true, а вот сравнения
7 > 12, false > true, "asdf" = "sdfa" - false.

Обратите внимание, что операции сравнения (в отличие от арифметических
операций) полиморфны, то есть одна и та же операция может применяться 
к разным типам. Важно только, чтобы левый и правый операнды имели одинаковый 
тип:
сравнения 3 < 1, 4. > 5., "abcd" = "dcba", false > true вполне допустимы, 
а сравнения 3 < 1., 4 > "ef" вызовут ошибку.

Синтаксис условного выражения такой:
<условное-выражение> ::= if <выражение> then <выражение> [ else <выражение> ]

Семантика условного выражения традиционна: если первое выражение (называемое
условием) истинно, значением всего условного выражения будет выражение,
указанного после слова then (обычно говорят, что значением будет значение
ветки then). В противном случае (когда условие ложно), значением выражение
будет значение ветки else. Если ветка else опущена, то это эквивалентно
следующему коду: if <выражение> then <выражение> else ()

Условное выражение - это один из возможных типов выражения, поэтому оно может
быть вложенным:

print\_string "x:\n";;
if a <> 0. then 
  print\_float ((c -. b) /. a)
else if b = c then
  print\_string "любое"
else
  print\_string "решений нет";;

Также, для избежания двусмысленностей, аргументы условного выражения
и само условное выражение можно брать в скобки - также, как и 
арифметические операции:

if a = 0. then print\_string (if b = c then "любое" else "решений нет")
          else print\_float ((c -. b) /. a);;

8.1. Напишите программу, сравнивающую 2 числа, введенных с клавиатуры,
     и печатающих, какое из чисел (1е или 2е) больше.          
8.2. Опишите функции max и min, вычисляющие максимум и минимум двух чисел.
8.3. Опишите функцию abs, вычисляющую модуль целого числа.
8.4. Напишите программу, находящую максимум из 3х введенных чисел.
8.5. Если даны три числа a <= b <= c, то число b называется их медианой.
     Это как бы среднее число - число, стоящее посередине.
     Напишите программу, находящую медиану трех чисел.
8.6. Решите задачи из п. 8.2 и 8.3 без применения условного оператора.
     Для этого вам, возможно, потребуется вычисление квадратного корня;
     это можно сделать с помощью функции sqrt: 
        let y = 16.;;
        let x = sqrt y;; (* теперь x = 4. *)




Представим теперь уравнение: слева написан образец, а справа значение. 
Например, как тут: \verb!let x = 15;;!. Такое уравнение и назовём сопоставлением с образцом.
Компилятор пытается подобрать для всех переменных слева какие-нибудь значения, такие,
чтобы равенство выполнилось, и если получается --- он присваивает переменным эти значения.

В частности, когда мы пишем \verb!let x = 15;;!, мы сопоставляем 15 с образцом \verb!x!, 
и компилятору несложно угадать значение переменной, чтобы левая и правая части совпали.
Также, прекрасно будет работать конструкция \verb!let (x,y) = (7,14);;! --- очевидно,
что здесь достаточно сопоставить переменной \verb!x! значение 7, а \verb!y! --- 14.
Компилятор с удовольствием будет решать даже бессмысленные уравнения:
\verb!let 4 = 4;;! --- это вполне корректный код.
Однако, если решений у уравнения нет, компилятор выдаст ошибку. Например,
так произойдёт в следующем примере: \verb!let 4 = 7;;!.

Отдельно надо отметить, что если образец использует какие-то другие конструкции,
кроме тех, что использованы выше, то всё кончится ошибкой компиляции. 
Уравнения произвольного вида, к сожалению, компилятору Окамля не по зубам. 
Не ждите, что он сможет решить что-нибудь такое: \verb!let x + 14 = 16;;!. 

С помощью этой конструкции легко получить значение из конструктора алгебраического типа.
Скажем, конструкция \verb!let One x = s! присвоит значение \verb!1.23! переменной 
\verb!x!, если переменная \verb!s! равнялась \verb!One 1.23!.
Но, если \verb!s! равняется, скажем, \verb!None!, решений у уравнения не будет
и мы получим ошибку: действительно, никакое плавающее число в переменной \verb!x! 
не выполнит равенство \verb!One x = None!.

Мы могли бы выйти из этой ситуации следующим громоздким кодом:

\begin{verbatim}
let s = solve a b c;;
if s = None then print_string "Нет решений"
else if s = Any then print_string "Любое целое число"
else let One x = s in print_string "x = "; print_float x
\end{verbatim}

Однако, есть метод лучше --- конструкция \verb!match!. 

