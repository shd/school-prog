%\chapter{Введение}
\setcounter{chapter}{1}
\section{Марковский алгорифм}
\par
Для начала, прежде чем мы перейдем к языкам программирования, использующимся 
на практике, мы познакомимся с \emph{Нормальным алгорифмом} --- моделью 
вычислительной машины, предложенной в середине XX века советским математиком 
Андреем Андреевичем Марковым. Эту модель еще называют \emph{Нормальным 
алгорифмом Маркова} или просто \emph{Марковским алгорифмом}.

Модель --- это некоторое упрощенное представление действительности, в котором
убраны все несущественные подробности и оставлено только то, что реально важно.
Модель вычислительной машины, соответственно --- это крайне простая
вычислительная машина, обычно существующая только на бумаге и в воображении,
не очень удобная для реальных применений, но незаменимая для исследования 
программ <<в общем>>. Мы будем использовать Марковский алгорифм для в чем-то
похожей цели --- для первого знакомства с языками программирования.
Здесь тоже важно, чтобы мелкие частности не закрывали общей картины.

\emph{Синтаксисом} языка мы будем называть правила, определяющие допустимые
тексты на этом языке. Слово <<правила>> мы пока понимаем в самом общем 
смысле, никак не ограничивая.

\emph{Семантика} языка --- это способ понимания того, 
что в тексте на данном языке записано, ведь одно и то же слово может на 
разных языках значить разное. 
Скажем, слово <<яма>> принадлежит и русскому и японскому языку.
 Тем не менее, смысл (семантика) 
этих слов различен: <<яма>> по-русски означает яму, а по-японски --- гору. 

\subsection{Синтаксис Марковского алгорифма}

Рассмотрим синтаксис Марковского алгорифма, для чего дадим несколько 
определений.

\begin{definition}
\emph{Алфавит} --- конечное множество символов. 
\end{definition}
\begin{example} \{\s{a},\s{b},\s{c}\}
или \{\s{0},\s{1},\s{2},\s{3},\s{4},\s
{5},\s{6},\s{7},\s{8},\s{9}\}.
\end{example}

\begin{definition}
\emph{Слово} или \emph{строка} --- конечная последовательность символов. Строка в 
алфавите A --- конечная последовательность символов из алфавита A. Строка может
быть \emph{пустой} --- то есть, не содержащей ни одного символа. 
Термины слово и строка равнозначны. 
\end{definition}

\begin{example}
\s{абба}, \s {ааааб} --- слова в алфавите \{\s{а},
\s{б}\}. 
\end{example}

Слово в данном контексте --- это очень формальный объект. Оно не обязано быть 
словом русского или какого-то другого естественного языка и иметь какой-либо 
смысл. Оно может содержать пробелы или знаки пунктуации, если эти знаки 
входят в алфавит. Словом может быть даже целая страница текста на русском 
языке. 

Слово, не содержащее никаких символов, мы назовём \emph{пустым}.
Для обозначения пустой строки часто используется символ $\varepsilon$.
Понятно, что слово, состоящее только из пробелов, и пустое слово различны.
Также различны слова из двух и из пяти пробелов.

\begin{definition}\emph{Правило} --- это запись вида 
\begin{bnf}\begin{eqnarray*}P &->& Q \end{eqnarray*}\end{bnf}После
стрелки может быть указана точка, такое правило мы назовем 
\emph{правилом с точкой}:
\begin{bnf}\begin{eqnarray*}P &->.& Q \end{eqnarray*}\end{bnf}Здесь 
P и Q --- слова, состоящие из символов алфавита A. 
Слово P будем называть левой частью правила, а слово Q - правой частью.
\end{definition}

\begin{example}В алфавите \{\s{a},\s{b},\s{c}\} следующие записи являются примерами правил: 
\begin{bnf}\begin{eqnarray*}
  \s{a} &->& \s{b}\\
  \s{aaa} &->.& \s{bbb}
\end{eqnarray*}
\end{bnf}Естественно, слова могут быть пустыми, поэтому следующие правила вполне допустимы:
\begin{bnf}\begin{eqnarray*}
 \s{a} &->&\\
 &->.& \s{a}\\
 &->&
\end{eqnarray*}\end{bnf}  
\end{example}

Теоретически нет никаких препятствий для вхожения точки и символа стрелки
в алфавит, но, чтобы избежать путаницы с записью правил, мы будем этого
избегать. В самом деле, если в качестве алфавита взять \{$\longrightarrow$, .\}, 
то есть 4 способа интерпретировать такую запись:
\begin{bnf}\begin{eqnarray*}
->.->->
\end{eqnarray*}\end{bnf}

\begin{definition} \emph{Схемой Марковского алгорифма}
назовем упорядоченную пару $\langle$A,R$\rangle$, где $A$ --- это алфавит, 
а $R$ --- упорядоченный набор правил. Всегда предполагается, что набор 
занумерован.
\end{definition}

\begin{example} Алфавит \{\s{а},\s{б},\s{в}\}. Правила:
\begin{bnf}
  \begin{eqnarray*}
   (1) \s{а}&->&\s{б}\\
   (2) \s{б}&->&\s{в}
\end{eqnarray*}\end{bnf}
\end{example}

Поскольку по упорядоченному списку нумерацию всегда легко 
восстановить, то при записи мы будем часто ее опускать, записывая
вышеуказанные правила вот так:

\begin{bnf}\begin{eqnarray*}
   \s{а}&->&\s{б}\\
   \s{б}&->&\s{в}
\end{eqnarray*}\end{bnf}  

\subsection{Семантика Марковского алгорифма}

Марковский алгорифм всегда применяется к какой-то начальной строке. 
Работа Алгорифма состоит из последовательности шагов, каждый шаг 
изменяет исходную строку, и эта измененная строка служит исходной строкой 
для следующего шага.

\vspace{3 mm}
Один шаг марковского алгорифма устроен так: 
\begin{itemize}
\item Найдем правило с минимальным номером, такое, что его левая 
часть является подстрокой исходной строки.

\begin{example}Рассмотрим такой набор правил:
\begin{bnf}\begin{eqnarray*}
   (1) \s{р}&->&\s{с}\\
   (2) \s{ааа}&->&\s{б}\\
   (3) \s{а}&->&\s{в}\\
   (4) \s{к}&->&\s{л}
\end{eqnarray*}\end{bnf}  
и такую входную строку:\begin{center}\s{кбааб}\end{center}

Первое правило, которое может быть применено - это правило (3), поскольку
строки \s{р} (правило 1) и \s{ааа} (правило 2) в строку 
\s{кбааб} не входят. 
\end{example}

\item Найдем в строке самое левое (то есть первое) вхождение левой части 
правила. Заменим это вхожение на правую часть правила. 

\begin{example}
   Первое вхождение подстроки \s{а} в строку \s{кбааб} подчеркнуто: 
   \s{кб\underline{а}аб}. Результат замены - строка \s{кбваб}. 
\end{example}

Строка, получившаяся в результате замены и будет являться результатом одного
шага Алгорифма.

\end{itemize}

На каждом шаге Алгорифм получает новую строку,
после чего Алгорифм делает следующий шаг, преобразуя уже эту новую строку.
Процесс повторяется, пока не произойдет одно из двух событий:

\begin{itemize}
\item
Не нашлось ни одного правила, которое можно было бы применить.
В этом случае Алгорифм останавливается, и результатом его работы будет
исходная для данного неудачного шага строка. 

\item
Применено правило с точкой. В этом случае Алгорифм также прекращает работу,
и результатом его работы будет результат применения этого правила.
Это единственное отличие правил с точкой от обычных правил.
\end{itemize}

\begin{example} Рассмотрим приведенный выше набор правил и исходную
строку \s{кбааб}. На первом шаге применяем правило (3),
получаем строку \s{кбваб}, на втором --- снова правило (3), получаем строку
\s{кбввб}, на третьем --- правило (4), получаем строку \s{лбввб}. 
Поскольку ни одно из четырех правил к строке \s{лбввб} не применить,
то Алгорифм остановится и эта строка и будет результатом его работы.
\end{example}

\begin{example} Алфавит \{\s{а},\s{б},\s{в}\}, правила:
\begin{bnf}\begin{eqnarray*}
   \s{а}&->&\s{б}\\
   \s{в}&->.&\\
   \s{бб}&->&\s{в}
\end{eqnarray*}\end{bnf}  

   На вход подается слово \s{абба}. Алгорифм последовательно получит 
   следующие слова и остановится, выполнив правило с точкой:
\begin{center}\s{абба} $\Rightarrow$ 
   \s{ббба} $\Rightarrow$ 
   \s{бббб} $\Rightarrow$ 
   \s{вбб}  $\Rightarrow$ 
   \s{бб}\end{center}
\end{example}

Обратите внимание на символ $\Rightarrow$ --- он означает <<получается из>>,
и предназначен для записи результата выполнения одного шага Алгорифма. 
Если же мы хотим указать, что строка $P$ через какое-то количество
шагов превратилась в строку $Q$, мы будем записывать это
с использованием троеточия:
\begin{center}\s{абба} $\Rightarrow\dots\Rightarrow$ \s{в}\end{center}
Не путайте эти стрелки со стрелками для записи правил! 

Совершенно необязательно, что Алгорифм в принципе закончит свою работу. 
Например, если в качестве алфавита взять \{\s{0},\s{1}\}, 
в качестве правил:
\begin{bnf}\begin{eqnarray*}
   \s{0}&->&\s{1}\\
   \s{1}&->&\s{0}
\end{eqnarray*}\end{bnf}и применить такой Алгорифм к строке \s{11}, то 
получится бесконечная последовательность шагов \begin{center}\s{11} 
$\Rightarrow$ \s{01} $\Rightarrow$ \s{11} $\Rightarrow$ \s{01} 
$\Rightarrow$ \s{11} $\Rightarrow \dots$\end{center}

На этом описание Марковского алгорифма заканчивается, в нем больше нет
никаких подробностей. 

\subsection{Задачи}

Вы можете дополнить алфавит, указанный в условии задачи, любыми буквами, 
которые вам потребуются. В более сложных задачах алфавит вам потребуется 
полностью определить самим. 

\begin{enumerate}
\item Сделать в алфавите 
\{\s{А},\s{Л},\s{М},\s{Н},\s
{О},\s{С},\s{У},\s{Х}\} из слова \s{МУХА} слово \s{СЛОН}.
На других словах поведение алгорифма может быть любым.

\item Сделать из слова \s{МЫШКА} слово \s{КОШКА}.

\item В строке из алфавита \{\s{а},\s{б}\} заменить все буквы \s{а} на \s{б}.

\item В алфавите \{\s{1},\s{2},\s{3}\} из пустой строки сделать 
строку \s{123}. На других
входных строках работа алгорифма может быть любой.

\item В алфавите \{\s{0},\s{1}\} сделать из любой строки строку 
\s{0110}.

\item Дан алфавит из двух цифр \{\s{0},\s{1}\}. Отсортировать 
цифры во входной строке по возрастанию. Например: \s{1000100111} 
$\Rightarrow\dots\Rightarrow$ \s{0000011111}.

\item Дан алфавит из четырех цифр \{\s{0},\s{1},\s{2},\s{3}\}. 
Отсортировать цифры во входной строке по возрастанию. Например: 
\s{12030011} $\Rightarrow\dots\Rightarrow$ \s{00011123}.

\item Дана строка из скобок \s{[} и \s{]}. Заменить все скобки на соответствующие
им парные. Пример: \s{[[][[[[} $\Rightarrow\dots\Rightarrow$ \s{]][]]]]}

Подсказка: алгорифм
\begin{bnf}\begin{eqnarray*}
\s{[}&->&\s{]}\\
\s{]}&->&\s{[}
\end{eqnarray*}\end{bnf}работать не будет, 
поскольку никогда не окончит своей работы.

\item Из строки, состоящей из повторяющейся последовательности букв \s{БА}
(конечной, но неизвестной заранее длины) сделать строку с тем же самым
количеством последовательностей \s{АБ}.
Например: \s{БАБАБАБА} $\Rightarrow\dots\Rightarrow$ \s{АБАБАБАБ}

\item По строке из алфавита \{\s{0}\} проверить, имеет ли строка четную длину.
Если да - то результатом работы алгорифма должна быть строка \s{четная}, если
нет - строка \s{нечетная}.

\item \emph{Правильная скобочная запись} --- такая строка из 
символов \s{(} и \s{)}, которую можно дополнить до корректного 
арифметического выражения с помощью цифр и знаков арифметических операций 
(добавлять скобки нельзя!). 
Например, запись \s{(()())} --- правильная, поскольку 
ее можно дополнить до корректного выражения таким образом: 
\s{((0+0)+(0+0))}. Запись \s{)(} правильной не является, поскольку 
ни в каком арифметическом выражении скобки в таком порядке идти не могут. 
Также, пустая строка - правильная запись, поскольку \s{1} - соответствующее 
корректное арифметическое выражение. 

Задача: проверить, является ли данная на входе строка из алфавита \{\s{(},\s{)}\}
правильной скобочной записью. Если запись правильная, результатом работы 
алгорифма должна быть строка \s{правильная}, а если запись - неправильная, 
то - строка \s{неправильная}.

Подсказка: алгорифм совсем не обязательно должен в лоб следовать 
определению. Вам требуется найти более подходящее свойство скобочной 
записи, которое может быть легко проверено.

\item Заменить число, записанное в двоичной системе счисления на 
соответствующее количество символов \s{|}. Например: 
\s{110} $\Rightarrow\dots\Rightarrow$ \s{||||||}.

\item Поставить символ \s{|} посередине слова четной длины (слово в алфавите
\{\s{а},\s{б}\}). 
Например: \s{абаб} $\Rightarrow\dots\Rightarrow$ \s{аб|аб}

\item Переставить буквы слова в алфавите \{\s{а},\s{б}\} в обратном порядке.

\item Cлово называется \emph{палиндромом}, если оно читается одинаково
как справа налево, так и слева направо. Например, слова \s{ТОПОТ} и 
\s{АННА} палиндромы, а слово \s{ТОПОР} --- нет. 

Проверить, является ли данное слово в алфавите \{\s{а},\s{б}\} 
палиндромом, и если да --- результатом должно быть слово \s{палиндром}, 
а если нет --- слово \s{не палиндром}.

\item Прибавить 1 к двоичному числу.

\item Сложить 2 двоичных числа.
\end{enumerate}
