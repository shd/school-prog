\documentclass[12pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage[left=1.5cm,right=1.5cm,top=1.5cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{bnf}
\newcommand{\s}[1]{\texttt{#1}}
\usepackage{proof}
\usepackage{tikz}

\begin{document}
\author{Д.Г. Штукенберг}
\title{Введение в программирование: Марковский алгорифм, грамматики и конечные автоматы}
\maketitle

\theoremstyle{definition}
\newtheorem{definition}{Определение}[section]
\theoremstyle{example}
\newtheorem{example}{Пример}[section]
\newtheorem{theorem}{Теорема}[section]
%\begin{center}
%{ { Лаборатория непрерывного математического образования}\\
%{\scshape {Введение в программирование: \\Марковский алгорифм, грамматики и конечные автоматы}\\\vspace{2mm}}
%{ Летний лагерь в Лужесно, 2015 г.}
%\end{center}
%\vspace{0.5cm}

\begin{abstract}
Данный курс в той или иной форме рассказывается новичкам, поступающим в ЛНМО;
обычно это происходит в летней школе. 
Курс предназначен для первоначального ознакомления с предметом.
Данный документ содержит краткий конспект теоретической части курса.
\end{abstract}

\section{Алгорифм Маркова}

Для начала, прежде чем мы перейдем к языкам программирования, использующимся 
на практике, мы познакомимся с \emph{Нормальным алгорифмом} --- моделью 
вычислительной машины, предложенной в середине XX века советским математиком 
Андреем Андреевичем Марковым. Эту модель еще называют \emph{Нормальным 
алгорифмом Маркова} или просто \emph{Марковским алгорифмом}.

Модель --- это некоторое упрощенное представление действительности, в котором
убраны все несущественные подробности и оставлено только то, что реально важно.
Модель вычислительной машины, соответственно --- это крайне простая
вычислительная машина, обычно существующая только на бумаге и в воображении,
не очень удобная для реальных применений, но незаменимая для исследования 
программ <<в общем>>. Мы будем использовать Марковский алгорифм для в чем-то
похожей цели --- для первого знакомства с языками программирования.
Здесь тоже важно, чтобы мелкие частности не закрывали общей картины.

\emph{Синтаксисом} языка мы будем называть правила, определяющие допустимые
тексты на этом языке. Слово <<правила>> мы пока понимаем в самом общем 
смысле, никак не ограничивая.

\emph{Семантика} языка --- это способ понимания того, 
что в тексте на данном языке записано, ведь одно и то же слово может на 
разных языках значить разное. 
Скажем, слово <<яма>> принадлежит и русскому и японскому языку.
 Тем не менее, смысл (семантика) 
этих слов различен: <<яма>> по-русски означает яму, а по-японски --- гору. 

\subsection{Синтаксис Марковского алгорифма}

Рассмотрим синтаксис Марковского алгорифма, для чего дадим несколько 
определений.

\begin{definition}
\emph{Алфавит} --- конечное множество символов. 
\end{definition}
\begin{example} \{\s{a},\s{b},\s{c}\}
или \{\s{0},\s{1},\s{2},\s{3},\s{4},\s
{5},\s{6},\s{7},\s{8},\s{9}\}.
\end{example}

\begin{definition}
\emph{Слово} или \emph{строка} --- конечная последовательность символов. Строка в 
алфавите A --- конечная последовательность символов из алфавита A. Строка может
быть \emph{пустой} --- то есть, не содержащей ни одного символа. 
Термины слово и строка равнозначны. 
\end{definition}

\begin{example}
\s{абба}, \s {ааааб} --- слова в алфавите \{\s{а},
\s{б}\}. 
\end{example}

Слово в данном контексте --- это очень формальный объект. Оно не обязано быть 
словом русского или какого-то другого естественного языка и иметь какой-либо 
смысл. Оно может содержать пробелы или знаки пунктуации, если эти знаки 
входят в алфавит. Словом может быть даже целая страница текста на русском 
языке. 

Слово, не содержащее никаких символов, мы назовём \emph{пустым}.
Для обозначения пустой строки часто используется символ $\varepsilon$.
Понятно, что слово, состоящее только из пробелов, и пустое слово различны.
Также различны слова из двух и из пяти пробелов.

\begin{definition}\emph{Правило} --- это запись вида 
\begin{bnf}\begin{eqnarray*}\alpha &->& \beta \end{eqnarray*}\end{bnf}После
стрелки может быть указана точка, такое правило мы назовем 
\emph{правилом с точкой}:
\begin{bnf}\begin{eqnarray*}\alpha &->.& \beta \end{eqnarray*}\end{bnf}Здесь 
$\alpha$ и $\beta$ --- слова, состоящие из символов алфавита A. 
Слово $\alpha$ будем называть левой частью правила, а слово $\beta$ --- правой частью.
\end{definition}

\begin{example}В алфавите \{\s{a},\s{b},\s{c}\} следующие записи являются примерами правил: 
\begin{bnf}\begin{eqnarray*}
  \s{a} &->& \s{b}\\
  \s{aaa} &->.& \s{bbb}
\end{eqnarray*}
\end{bnf}Естественно, слова могут быть пустыми, поэтому следующие правила вполне допустимы:
\begin{bnf}\begin{eqnarray*}
 \s{a} &->&\\
 &->.& \s{a}\\
 &->&
\end{eqnarray*}\end{bnf}  
\end{example}

Чтобы понимать друг друга, мы должны различать предметный язык и метаязык. \emph{Предметный язык} --- это
изучаемый язык; в случае алгоритмов Маркова это тексты программ на алгорифме Маркова.
\emph{Метаязык} --- наши комментарии, общие замечания и т.п., служащие пониманию текстов программ.
Отсюда два соглашения:

\begin{enumerate}
\item Нет никаких препятствий для вхожения точки и символа стрелки
в алфавит, но, чтобы избежать путаницы с записью правил, мы будем этого
избегать. В самом деле, если в качестве алфавита взять \{$\longrightarrow$, .\}, 
то следующую строку можно прочесть четырьмя разными способами (какими?)
\begin{bnf}\begin{eqnarray*}
->.->->
\end{eqnarray*}\end{bnf}

\item По умолчанию, мы будем использовать греческие буквы $\alpha,\beta,\gamma,\dots$ для
указания строк, а для алфавита использовать маленькие латинские и русские буквы и цифры.
\end{enumerate}

\begin{definition} \emph{Схемой Марковского алгорифма}
назовем упорядоченную пару $\langle$A,R$\rangle$, где $A$ --- это алфавит, 
а $R$ --- упорядоченный набор правил. Всегда предполагается, что набор 
занумерован.
\end{definition}

\begin{example} Алфавит \{\s{а},\s{б},\s{в}\}. Правила:
\begin{bnf}
  \begin{eqnarray*}
   (1) \s{а}&->&\s{б}\\
   (2) \s{б}&->&\s{в}
\end{eqnarray*}\end{bnf}
\end{example}

Поскольку по упорядоченному списку нумерацию всегда легко 
восстановить, то при записи мы будем часто ее опускать, записывая
вышеуказанные правила вот так:

\begin{bnf}\begin{eqnarray*}
   \s{а}&->&\s{б}\\
   \s{б}&->&\s{в}
\end{eqnarray*}\end{bnf}  

\subsection{Семантика Марковского алгорифма}

Марковский алгорифм всегда применяется к какой-то начальной строке. 
Работа Алгорифма состоит из последовательности шагов, каждый шаг 
изменяет исходную строку, и эта измененная строка служит исходной строкой 
для следующего шага.

\vspace{3 mm}
Один шаг марковского алгорифма устроен так: 
\begin{itemize}
\item Найдем правило с минимальным номером, такое, что его левая 
часть является подстрокой исходной строки.

\begin{example}Рассмотрим такой набор правил:
\begin{bnf}\begin{eqnarray*}
   (1) \s{р}&->&\s{с}\\
   (2) \s{ааа}&->&\s{б}\\
   (3) \s{а}&->&\s{в}\\
   (4) \s{к}&->&\s{л}
\end{eqnarray*}\end{bnf}  
и такую входную строку:\begin{center}\s{кбааб}\end{center}

Первое правило, которое может быть применено - это правило (3), поскольку
строки \s{р} (правило 1) и \s{ааа} (правило 2) в строку 
\s{кбааб} не входят. 
\end{example}

\item Найдем в строке самое левое (то есть первое) вхождение левой части 
правила. Заменим это вхожение на правую часть правила. 

\begin{example}
   Первое вхождение подстроки \s{а} в строку \s{кбааб} подчеркнуто: 
   \s{кб\underline{а}аб}. Результат замены - строка \s{кбваб}. 
\end{example}

Строка, получившаяся в результате замены и будет являться результатом одного
шага Алгорифма.

\end{itemize}

На каждом шаге Алгорифм получает новую строку,
после чего Алгорифм делает следующий шаг, преобразуя уже эту новую строку.
Процесс повторяется, пока не произойдет одно из двух событий:

\begin{itemize}
\item
Не нашлось ни одного правила, которое можно было бы применить.
В этом случае Алгорифм останавливается, и результатом его работы будет
исходная для данного неудачного шага строка. 

\item
Применено правило с точкой. В этом случае Алгорифм также прекращает работу,
и результатом его работы будет результат применения этого правила.
Это единственное отличие правил с точкой от обычных правил.
\end{itemize}

\begin{example} Рассмотрим приведенный выше набор правил и исходную
строку \s{кбааб}. На первом шаге применяем правило (3),
получаем строку \s{кбваб}, на втором --- снова правило (3), получаем строку
\s{кбввб}, на третьем --- правило (4), получаем строку \s{лбввб}. 
Поскольку ни одно из четырех правил к строке \s{лбввб} не применить,
то Алгорифм остановится и эта строка и будет результатом его работы.
\end{example}

\begin{example} Алфавит \{\s{а},\s{б},\s{в}\}, правила:
\begin{bnf}\begin{eqnarray*}
   \s{а}&->&\s{б}\\
   \s{в}&->.&\\
   \s{бб}&->&\s{в}
\end{eqnarray*}\end{bnf}  

   На вход подается слово \s{абба}. Алгорифм последовательно получит 
   следующие слова и остановится, выполнив правило с точкой:
\begin{center}\s{абба} $\Rightarrow$ 
   \s{ббба} $\Rightarrow$ 
   \s{бббб} $\Rightarrow$ 
   \s{вбб}  $\Rightarrow$ 
   \s{бб}\end{center}
\end{example}

Обратите внимание на символ $\Rightarrow$ --- он означает <<получается из>>,
и предназначен для записи результата выполнения одного шага Алгорифма. 
Если же мы хотим указать, что строка $P$ через какое-то количество
шагов превратилась в строку $Q$, мы будем записывать это
с использованием троеточия:
\begin{center}\s{абба} $\Rightarrow\dots\Rightarrow$ \s{в}\end{center}
Не путайте эти стрелки со стрелками для записи правил! 

Совершенно необязательно, что Алгорифм в принципе закончит свою работу. 
Например, если в качестве алфавита взять \{\s{0},\s{1}\}, 
в качестве правил:
\begin{bnf}\begin{eqnarray*}
   \s{0}&->&\s{1}\\
   \s{1}&->&\s{0}
\end{eqnarray*}\end{bnf}и применить такой Алгорифм к строке \s{11}, то 
получится бесконечная последовательность шагов \begin{center}\s{11} 
$\Rightarrow$ \s{01} $\Rightarrow$ \s{11} $\Rightarrow$ \s{01} 
$\Rightarrow$ \s{11} $\Rightarrow \dots$\end{center}

На этом описание Марковского алгорифма заканчивается, в нем больше нет
никаких подробностей. 

\subsection{Задачи}

Вы можете дополнить алфавит, указанный в условии задачи, любыми буквами, 
которые вам потребуются. В более сложных задачах алфавит вам потребуется 
полностью определить самим. 

\begin{enumerate}
\item Сделать в алфавите 
\{\s{А},\s{Л},\s{М},\s{Н},\s
{О},\s{С},\s{У},\s{Х}\} из слова \s{МУХА} слово \s{СЛОН}.
На других словах поведение алгорифма может быть любым.

\item Сделать из слова \s{МЫШКА} слово \s{КОШКА}.

\item В строке из алфавита \{\s{а},\s{б}\} заменить все буквы \s{а} на \s{б}.

\item В алфавите \{\s{1},\s{2},\s{3}\} из пустой строки сделать 
строку \s{123}. На других
входных строках работа алгорифма может быть любой.

\item В алфавите \{\s{0},\s{1}\} сделать из любой строки строку 
\s{0110}.

\item Дан алфавит из двух цифр \{\s{0},\s{1}\}. Отсортировать 
цифры во входной строке по возрастанию. Например: \s{1000100111} 
$\Rightarrow\dots\Rightarrow$ \s{0000011111}.

\item Дан алфавит из четырех цифр \{\s{0},\s{1},\s{2},\s{3}\}. 
Отсортировать цифры во входной строке по возрастанию. Например: 
\s{12030011} $\Rightarrow\dots\Rightarrow$ \s{00011123}.

\item Дана строка из скобок \s{[} и \s{]}. Заменить все скобки на соответствующие
им парные. Пример: \s{[[][[[[} $\Rightarrow\dots\Rightarrow$ \s{]][]]]]}

Подсказка: алгорифм
\begin{bnf}\begin{eqnarray*}
\s{[}&->&\s{]}\\
\s{]}&->&\s{[}
\end{eqnarray*}\end{bnf}работать не будет, 
поскольку никогда не окончит своей работы.

\item Из строки, состоящей из повторяющейся последовательности букв \s{БА}
(конечной, но неизвестной заранее длины) сделать строку с тем же самым
количеством последовательностей \s{АБ}.
Например: \s{БАБАБАБА} $\Rightarrow\dots\Rightarrow$ \s{АБАБАБАБ}

\item По строке из алфавита \{\s{0}\} проверить, имеет ли строка четную длину.
Если да --- то результатом работы алгорифма должна быть строка \s{четная}, если
нет --- строка \s{нечетная}.

\item \emph{Правильная скобочная запись} --- такая строка из 
символов \s{(} и \s{)}, которую можно дополнить до корректного 
арифметического выражения с помощью цифр и знаков арифметических операций 
(добавлять скобки нельзя!). 
Например, запись \s{(()())} --- правильная, поскольку 
ее можно дополнить до корректного выражения таким образом: 
\s{((0+0)+(0+0))}. Запись \s{)(} правильной не является, поскольку 
ни в каком арифметическом выражении скобки в таком порядке идти не могут. 
Также, пустая строка - правильная запись, поскольку \s{1} - соответствующее 
корректное арифметическое выражение. 

Задача: проверить, является ли данная на входе строка из алфавита \{\s{(},\s{)}\}
правильной скобочной записью. Если запись правильная, результатом работы 
алгорифма должна быть строка \s{правильная}, а если запись - неправильная, 
то - строка \s{неправильная}.

Подсказка: алгорифм совсем не обязательно должен в лоб следовать 
определению. Вам, возможно, будет удобно найти более подходящее свойство скобочной 
записи, которое может быть легко проверено.

Пример: \s{(())} $\Rightarrow\dots\Rightarrow$ \s{правильная}.

\item Заменить число, записанное в двоичной системе счисления на 
соответствующее количество символов \s{|}. Например: 
\s{110} $\Rightarrow\dots\Rightarrow$ \s{||||||}.

\item Поставить символ \s{|} посередине слова четной длины (слово в алфавите
\{\s{а},\s{б}\}). 
Например: \s{абаб} $\Rightarrow\dots\Rightarrow$ \s{аб|аб}

\item Переставить буквы слова в алфавите \{\s{а},\s{б}\} в обратном порядке.

\item Cлово называется \emph{палиндромом}, если оно читается одинаково
как справа налево, так и слева направо. Например, слова \s{ТОПОТ} и 
\s{АННА} палиндромы, а слово \s{ТОПОР} --- нет. 

Проверить, является ли данное слово в алфавите \{\s{а},\s{б}\} 
палиндромом, и если да --- результатом должно быть слово \s{палиндром}, 
а если нет --- слово \s{не палиндром}.

\item Проверить, что число в двоичной записи равно 0.
\item Проверить число в двоичной записи на чётность.
\item Проверить число в четверичной записи на делимость на 3 ($222_4$ делится на 3, но $221_4$ --- нет).

\item Прибавить 1 к двоичному числу.

\item Сложить два двоичных числа.
\end{enumerate}

%\subsection{Синтаксис алгорифма Маркова}
%
%\begin{definition}Алфавит --- конечное множество символов.
%\end{definition}
%
%\begin{definition}Слово --- конечная последовательность символов. Слово в алфавите $A$ ---
%конечная последовательность символов из алфавита $A$.
%\end{definition}
%
%\begin{definition}Язык --- множество слов.
%\end{definition}
%
%\begin{definition}Правило --- запись, имеющая такой вид 
%\begin{bnf}\begin{eqnarray*}
%\alpha&\rightarrow&\beta\\
%\end{eqnarray*}\end{bnf}
%\vspace{-1cm}
%
%или такой вид:
%\begin{bnf}\begin{eqnarray*}
%\alpha&\rightarrow.&\beta\\
%\end{eqnarray*}\end{bnf}
%
%\vspace{-1cm}
%Здесь греческие буквы ($\alpha$ и $\beta$) обозначают произвольные слова в некотором алфавите.
%
%\end{definition}
%
%\begin{definition}Чтобы задать алгорифм Маркова, необходимо задать:
%\begin{itemize}
%\item Алфавит
%\item Упорядоченный набор правил
%\end{itemize}
%\end{definition}
%
%\subsection{Семантика алгорифма Маркова}
%
%\begin{definition}Применимое правило.
%Назовем правило применимым к некоторой строке, если его левая часть входит в
%эту строку.
%\end{definition}
%
%\begin{definition}Шаг алгорифма Маркова. 
%Пусть задана некоторая строка. Найдем первое применимое правило 
%алгорифма Маркова. Возьмем самое левое вхождение левой части этого
%правила и заменим его на правую часть правила. 
%Получившаяся строка будет называться результатом применения шага
%алгорифма Маркова к исходной строке.
%
%Если ни одно правило не применимо, то мы будем говорить, что 
%сделать шаг невозможно.
%\end{definition}
%
%\begin{definition}Результат применения алгорифма Маркова.
%Пусть задана некоторая строка. Будем применять шаги алгорифма Маркова,
%каждый следующий шаг применяя к результату предыдущего шага,
%пока шаги возможно выполнять и пока не было выполнено ни одного правила с точкой.
%
%В случае, если какое-то из условий нарушено (т.е. не осталось применимых 
%правил, либо выполнилось правило с точкой), то результат последнего
%выполненного шага назовем результатом применения алгорифма Маркова.
%\end{definition}
%
\section{Грамматика}

\begin{definition}
Чтобы задать грамматику, необходимо задать:
\begin{itemize}
\item Алфавит ($A$), состоящий из двух непересекающихся конечных 
множества символов, называемых 
алфавитами терминальных ($A_T$) и нетерминальных ($A_H$) символов:
$$A = A_T \cup A_H, ~~~ A_T \cap A_H = \varnothing$$
\item Набор правил без точек в алфавите $A$, в каждом из которых которых левая часть 
содержит по крайней мере один нетерминальный символ
\item Начальный символ --- некоторый символ из $A_H$.
\end{itemize}
\end{definition} 

\begin{definition}
Будем говорить, что слово $s$ задаётся грамматикой, если выполнены следующие два утверждения:
\begin{itemize}
\item Оно целиком состоит из терминальных символов данной грамматики;
\item Существует последовательность применения правил, которая преобразует
начальный символ в слово $s$. В данном случае мы разрешаем применять правила
в произвольном порядке к произвольным вхождениям в строке, не требуя применения 
самого первого правила к самому левому вхождению.
\end{itemize}
\end{definition}

\begin{definition}
Будем говорить, что язык задается грамматикой, если грамматика задает те и только
те слова, которые входят в язык.
\end{definition}

\section{Сокращения записи}

Для упрощения записи мы будем пользоваться следующими сокращениями, которые 
можно раскрыть в традиционную грамматику.

\subsection{Альтернатива}

Будем писать $\alpha \rightarrow \beta | \gamma$ вместо двух строчек
\begin{bnf}\begin{eqnarray*}
\alpha &\rightarrow&\beta\\
\alpha &\rightarrow&\gamma
\end{eqnarray*}\end{bnf}
\vspace{-0.3cm}

Данная запись означает <<строчка $\alpha$ может быть преобразована либо в $\beta$,
либо в $\gamma$>>.

\subsection{Необязательная часть}

Будем писать $\alpha \rightarrow [\beta]$ вместо двух строчек
\begin{bnf}\begin{eqnarray*}
\alpha &\rightarrow&\\
\alpha &\rightarrow&\beta
\end{eqnarray*}\end{bnf}
\vspace{-0.7cm}

Данная запись означает <<строчка $\alpha$ может быть преобразована либо в $\beta$,
либо в пустую строку>>.

\subsection{Повторение}

Будем писать $\alpha \rightarrow \{\beta\}^*$ вместо таких строчек
\begin{bnf}\begin{eqnarray*}
\alpha &\rightarrow&S\\
S &\rightarrow& \beta S \\
S &\rightarrow& \varepsilon
\end{eqnarray*}\end{bnf}
\vspace{-0.3cm}

Здесь $S$ --- некоторый новый, ранее не встречавшийся в данной грамматике нетерминальный
символ. 

Данная запись означает повторение строчки $\beta$ ноль или более раз.

Аналогично мы можем рассмотреть повторение строки один или более раз:
$\alpha \rightarrow \{\beta\}^+$ вместо строчек
\begin{bnf}\begin{eqnarray*}
\alpha &\rightarrow&S\\
S &\rightarrow& \beta S \\
S &\rightarrow& \beta
\end{eqnarray*}\end{bnf}
\vspace{-0.3cm}

Эти два типа повторения легко выражаются один через другой: как $\{\alpha\}^+$ можно
представить как $\alpha\{\alpha\}^*$, так и $\{\alpha\}^*$ --- как $\varepsilon | \{\alpha\}^+$.

\section{Иерархия Хомского}

\begin{definition}
Назовем грамматику неукорачивающей, если все правила в этой
грамматике имеют в левой части не больше символов, чем
в соответствующей правой части.
Грамматика также может содержать правило вида $S \rightarrow \varepsilon$, но только
если нетерминал $S$ не содержится в правых частях правил.
\end{definition}

\begin{definition}
Назовем грамматику бесконтекстной (контекстно-свободной), если все правила в этой
грамматике имеют в левой части в точности один нетерминальный символ и ничего, кроме
него.
\end{definition}

\begin{definition}
Назовем грамматику построенной по регулярному выражению, если:
\begin{itemize}
\item Алфавит нетерминальных символов состоит в точности из одного символа
\item Грамматика имеет единственное правило, левая часть которого --- нетерминальный
символ, а правая состоит только из терминальных символов. Также, в правой части
разрешено использовать сокращения записи (операции <<альтернатива>>, 
<<необязательная часть>> и <<повторение>>).
\end{itemize}
\end{definition}

\begin{definition}
Будем говорить, что язык --- неукорачивающий (бесконтекстный, автоматный), если
он может быть задан соответствующей грамматикой. 
\end{definition}

\begin{definition}Иерархия Хомского имеет 4 уровня:

\vspace{0.3cm}

\begin{tabular}{ll}
Уровень в иерархии&Тип грамматики\\
\hline
0 & Грамматика общего вида\\
1 & Неукорачивающая\\
2 & Бесконтекстная\\
3 & Регулярная
\end{tabular}
\end{definition}

Легко заметить, что если грамматика (язык) принадлежит уровню $k$ иерархии Хомского, 
то он принадлежит и всем уровням, меньшим $k$.

\section{Регулярные выражения и конечные автоматы}

\begin{definition}
Конечным автоматом мы назовем совокупность:
\begin{itemize}
\item двух алфавитов --- алфавита терминальных символов $A_T$ и алфавита состояний $A_C$;
\item таблицы переходов, сопоставляющей паре символов --- терминальному и состоянию --- некоторое
новое состояние: $T: A_T\times A_C \rightarrow A_C$;
\item начального состояния и множества допускающих состояний.
\end{itemize}
\end{definition}

\begin{definition}
Шаг применения конечного автомата. Если автомат находится в некотором состоянии
$s \in A_C$, то результатом применения автомата к некоторому символу $a \in A_T$
будет новое состояние $T[s,a]$.
\end{definition}

\begin{definition}
Будем говорить, что автомат допускает некоторую строку, если последовательное применение
автомата ко всем символам из строки в порядке их записи в слове приводит автомат
из начального в допускающее состояние.
\end{definition}

\begin{definition}
Будем говорить, что автомат задаёт язык, если он допускает те и только те слова, которые
принадлежат языку.
\end{definition}

\subsection{Недетерминированные конечные автоматы}

Введем альтернативный способ изображения конечных автоматов --- в виде графа.
Будем сопоставлять состояниям автомата точки, а клеткам таблицы переходов --- дуги.
Допускающие состояния будем обозначать двойным кружком, начальное состояние --- входящей стрелкой.
Если дуги для символа для какого-то состояния не указано, то появление такого символа ведёт к недопуску 
строки.

Пример задания одного и того же автомата с помощью таблицы и с помощью графа:
\vspace{3mm}

\begin{tabular}{cc}

\begin{minipage}{5cm}
\begin{tabular}{c|cc}
& $a$ & $b$\\
\hline
$S_0$ & $S_1$ & $S_0$\\
$S_1$ & $S_2$ & $S_0$\\
$S_2$ & $S_2$ & $S_3$\\
$S_3^*$ & $S_3$ & $S_3$\\

\end{tabular}

\end{minipage}

&

\begin{minipage}{8cm}
\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{vertex}=[circle,draw,text=black]

  \node[vertex]   (A) {$S_0$};
  \node[vertex]   (B) [right of=A] {$S_1$};
  \node[vertex]   (C) [right of=B] {$S_2$};
  \node[vertex,double]   (D) [right of=C] {$S_3$};

  \draw [<-] (A) to node[auto] {} ++ (-1,0);
  \path (A) edge              node {a} (B)
            edge [loop above] node {b} (A)
        (B) edge [bend right] node[swap] {b} (A)
            edge              node {a} (C)
        (C) edge              node {b} (D)
	    edge [loop above] node {a} (C)
        (D) edge [loop above] node {a,b} (D);
\end{tikzpicture}

\end{minipage}

\end{tabular}


\begin{definition}
Недетерминированный конечный автомат --- это конечный автомат, в котором в каждой клетке
таблицы переходов записано не одно состояние, а множество состояний. То есть, функция 
переходов задаётся иначе: $T: A_T\times A_C \rightarrow 2^{A_C}$.
\end{definition}

\begin{definition}
Мы будем говорить, что недетерминированный конечный автомат допускает строку, если
на каждом шаге применения автомата к символам входной строки (то есть, на символе
$t \in A_T$ и в состоянии $s \in A_C$) найдётся такой переход (из множества допустимых 
переходов $T[t,s]$), что после последнего шага автомата он окажется в допускающем
состоянии.
\end{definition}

То же самое можно выразить несколько парадоксальной фразой: недетерминированный автомат 
на каждом шагу <<угадывает>>, какой из вариантов перехода выбрать, чтобы достигнуть 
допускающего состояния. 

\begin{definition}
Недетерминированный конечный автомат с эпсилон-переходами --- 
конечный автомат, в котором к алфавиту терминальных символов добавлен <<пустой>> символ
$\varepsilon$, не встречающийся во входной строке.
\end{definition}

\begin{definition}
Назовём состояние $r$ $\varepsilon$-достижимым из состояния $s$, если существует последовательность
$\varepsilon$-переходов, позволяющая достичь $r$ из $s$.
\end{definition}

\begin{definition}
Мы будем говорить, что недетерминированный конечный автомат с $\varepsilon$-переходами 
допускает строку, если на каждом шаге применения автомата к символам входной строки 
(то есть, на символе $t \in A_T$ и в состоянии $s \in A_C$) найдётся такое 
$\varepsilon$-достижимое состояние $r$ и такой переход из него (из множества допустимых 
переходов $T[t,r]$), что после последнего шага автомата допускающее состояние окажется
$\varepsilon$-достижимо.
\end{definition}

Иными словами, недетерминированный конечный автомат с $\varepsilon$-переходами может в
любой момент самопроизвольно выполнить любое количество $\varepsilon$-переходов,
если это ведёт к цели (к допуску строчки).

\begin{theorem}
По любому недетерминированному автомату с $\varepsilon$-переходами 
можно построить детерминированный, задающий тот же язык
\end{theorem}

Теорема доказывается путём рассмотрения автомата с алфавитом из $2^{A_C}$ состояний. 
Из этой теоремы следует, что классы языков, задаваемые и детерминированными и
недетерминированными автоматами, одинаковы. Однако, в разных задачах удобен разный тип
автоматов.

\subsection{Соответствие регулярных выражений конечным автоматам}

Известно, что грамматики, построенные по регулярным выражениям, задают в точности то же 
множество языков, что и конечные автоматы.
Мы можем это показать, например, двумя включениями: показав, как заданный грамматикой язык
задать конечным автоматом --- и как язык, заданный конечным автоматом, задать с помощью 
грамматики, построенной по регулярному выражению.

Мы покажем, как преобразовать регулярное выражение в недетерминированный конечный автомат, задающий 
тот же язык. 
Обратное преобразование также можно произвести, но оно останется за рамками данного курса.

В регулярном выражении возможны 4 типа конструкций: литерал (терминальный символ),
конкатенация ($\alpha\beta$), альтернатива ($\alpha|\beta$)
и повторение ($\{\alpha\}^+$). Нам достаточно предложить способ построения автомата для
литералов и способы построения более сложных автоматов на основе уже имеющихся в остальных 
трёх типах конструкций. 

\begin{enumerate}
\item Литерал. Автомат, допускающий символ $x$ (и только его), выглядит так:

\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{vertex}=[circle,draw,text=black]

  \node[vertex]   (A) {$S_0$};
  \node[vertex,double]   (B) [right of=A] {$S_1$};

  \draw [<-] (A) to node[auto] {} ++ (-1,0);
  \path (A) edge              node {$x$} (B);
\end{tikzpicture}

\item Конкатенация. Пусть даны два автомата, задающие $\alpha$ и $\beta$ 
(они схематично изображены квадратами на графе).
Тогда автоматом, задающим $\alpha\beta$, будет

\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{vertex}=[draw,text=black]

  \node[vertex,circle] (S) {$S_0$};
  \node[vertex,rectangle,minimum height=1 cm, minimum width = 1cm]   (A) [right of=S] {$\alpha$};
  \node[vertex,rectangle,minimum height=1 cm, minimum width = 1cm]   (B) [right of=A] {$\beta$};
  \node[vertex,double,circle] (E) [right of=B] {$S_1$};

  \draw [<-] (S) to node[auto] {} ++ (-1,0);
  \path (S) edge   node  {$\varepsilon$}(A)
        (A) edge   node  {$\varepsilon$}(B)
        (B) edge   node  {$\varepsilon$}(E);
\end{tikzpicture}

\item Альтернатива. Пусть даны два автомата, задающие $\alpha$ и $\beta$.
Тогда автоматом, задающим $\alpha|\beta$, будет

\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{vertex}=[draw,text=black]

  \node[vertex,circle] (S) {$S_0$};
  \node[vertex,rectangle,minimum height=1 cm, minimum width = 1cm]   (A) at (2,1) {$\alpha$};
  \node[vertex,rectangle,minimum height=1 cm, minimum width = 1cm]   (B) at (2,-1) {$\beta$};
  \node[vertex,double,circle] (E) at (4,0) {$S_1$};

  \draw [<-] (S) to node[auto] {} ++ (-1,0);
  \path (S) edge   node  {$\varepsilon$}(A)
        (S) edge   node  {$\varepsilon$}(B)
        (A) edge   node  {$\varepsilon$}(E)
        (B) edge   node  {$\varepsilon$}(E);
\end{tikzpicture}

\item Повторение. Пусть дан автомат, задающий $\alpha$. Тогда автоматом, задающим $\{\alpha\}^+$, будет

\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{vertex}=[draw,text=black]

  \node[vertex,circle] (S) {$S_0$};
  \node[vertex,rectangle,minimum height=1 cm, minimum width = 1cm]   (A) [right of=S] {$\alpha$};
  \node[vertex,double,circle] (E) [right of=A] {$S_1$};

  \draw [<-] (S) to node[auto] {} ++ (-1,0);
  \path (S) edge   node  {$\varepsilon$}(A)
        (E) edge  [bend right=40] node [swap] {$\varepsilon$}(S)
        (A) edge   node  {$\varepsilon$}(E);
\end{tikzpicture}

\end{enumerate}

При помощи этих четырёх примитивов можно последовательно построить автомат, соответствующий любому
регулярному выражению.

\end{document}
