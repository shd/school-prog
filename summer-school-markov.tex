\documentclass[12pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage[left=1.5cm,right=1.5cm,top=1.5cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{bnf}
\newcommand{\s}[1]{\texttt{#1}}
\usepackage{proof}
\usepackage{tikz}

\begin{document}
\theoremstyle{definition}
\newtheorem{definition}{Определение}[section]

\begin{center}
{\textit { Лаборатория непрерывного математического образования}\\
\textbf{\large{Введение в программирование:}\\\vspace{1mm}
{\Large Марковский алгорифм, грамматики и конечные автоматы}}\\\vspace{2mm}}
%{ Летний лагерь в Лужесно, 2015 г.}
\end{center}
%\vspace{0.5cm}

\begin{abstract}
Данный курс в той или иной форме рассказывается новичкам, поступающим в ЛНМО;
обычно это происходит в летней школе. 
Курс предназначен для первоначального ознакомления с предметом.
Данный документ содержит краткий конспект теоретической части курса.
\end{abstract}

\section{Алгорифм Маркова}

\subsection{Синтаксис алгорифма Маркова}

\begin{definition}Алфавит --- конечное множество символов.
\end{definition}

\begin{definition}Слово --- конечная последовательность символов. Слово в алфавите $A$ ---
конечная последовательность символов из алфавита $A$.
\end{definition}

\begin{definition}Язык --- множество слов.
\end{definition}

\begin{definition}Правило --- запись, имеющая такой вид 
\begin{bnf}\begin{eqnarray*}
\alpha&\rightarrow&\beta\\
\end{eqnarray*}\end{bnf}
\vspace{-1cm}

или такой вид:
\begin{bnf}\begin{eqnarray*}
\alpha&\rightarrow.&\beta\\
\end{eqnarray*}\end{bnf}

\vspace{-1cm}
Здесь греческие буквы ($\alpha$ и $\beta$) обозначают произвольные слова в некотором алфавите.

\end{definition}

\begin{definition}Чтобы задать алгорифм Маркова, необходимо задать:
\begin{itemize}
\item Алфавит
\item Упорядоченный набор правил
\end{itemize}
\end{definition}

\subsection{Семантика алгорифма Маркова}

\begin{definition}Применимое правило.
Назовем правило применимым к некоторой строке, если его левая часть входит в
эту строку.
\end{definition}

\begin{definition}Шаг алгорифма Маркова. 
Пусть задана некоторая строка. Найдем первое применимое правило 
алгорифма Маркова. Возьмем самое левое вхождение левой части этого
правила и заменим его на правую часть правила. 
Получившаяся строка будет называться результатом применения шага
алгорифма Маркова к исходной строке.

Если ни одно правило не применимо, то мы будем говорить, что 
сделать шаг невозможно.
\end{definition}

\begin{definition}Результат применения алгорифма Маркова.
Пусть задана некоторая строка. Будем применять шаги алгорифма Маркова,
каждый следующий шаг применяя к результату предыдущего шага,
пока шаги возможно выполнять и пока не было выполнено ни одного правила с точкой.

В случае, если какое-то из условий нарушено (т.е. не осталось применимых 
правил, либо выполнилось правило с точкой), то результат последнего
выполненного шага назовем результатом применения алгорифма Маркова.
\end{definition}

\section{Грамматика}

\begin{definition}
Чтобы задать грамматику, необходимо задать:
\begin{itemize}
\item Алфавит ($A$), состоящий из двух непересекающихся конечных 
множества символов, называемых 
алфавитами терминальных ($A_T$) и нетерминальных ($A_H$) символов:
$$A = A_T \cup A_H, ~~~ A_T \cap A_H = \varnothing$$
\item Набор правил без точек в алфавите $A$, в каждом из которых которых левая часть 
содержит по крайней мере один нетерминальный символ
\item Начальный символ --- некоторый символ из $A_H$.
\end{itemize}
\end{definition} 

\begin{definition}
Будем говорить, что слово $s$ задаётся грамматикой, если выполнены следующие два утверждения:
\begin{itemize}
\item Оно целиком состоит из терминальных символов данной грамматики;
\item Существует последовательность применения правил, которая преобразует
начальный символ в слово $s$. В данном случае мы разрешаем применять правила
в произвольном порядке к произвольным вхождениям в строке, не требуя применения 
самого первого правила к самому левому вхождению.
\end{itemize}
\end{definition}

\begin{definition}
Будем говорить, что язык задается грамматикой, если грамматика задает те и только
те слова, которые входят в язык.
\end{definition}

\section{Сокращения записи}

Для упрощения записи мы будем пользоваться следующими сокращениями, которые 
можно раскрыть в традиционную грамматику.

\subsection{Альтернатива}

Будем писать $\alpha \rightarrow \beta | \gamma$ вместо двух строчек
\begin{bnf}\begin{eqnarray*}
\alpha &\rightarrow&\beta\\
\alpha &\rightarrow&\gamma
\end{eqnarray*}\end{bnf}
\vspace{-0.3cm}

Данная запись означает <<строчка $\alpha$ может быть преобразована либо в $\beta$,
либо в $\gamma$>>.

\subsection{Необязательная часть}

Будем писать $\alpha \rightarrow [\beta]$ вместо двух строчек
\begin{bnf}\begin{eqnarray*}
\alpha &\rightarrow&\\
\alpha &\rightarrow&\beta
\end{eqnarray*}\end{bnf}
\vspace{-0.7cm}

Данная запись означает <<строчка $\alpha$ может быть преобразована либо в $\beta$,
либо в пустую строку>>.

\subsection{Повторение}

Будем писать $\alpha \rightarrow \{\beta\}^*$ вместо таких строчек
\begin{bnf}\begin{eqnarray*}
\alpha &\rightarrow&S\\
S &\rightarrow& \beta S \\
S &\rightarrow& \varepsilon
\end{eqnarray*}\end{bnf}
\vspace{-0.3cm}

Здесь $S$ --- некоторый новый, ранее не встречавшийся в данной грамматике нетерминальный
символ. 

Данная запись означает повторение строчки $\beta$ ноль или более раз.

Аналогично мы можем рассмотреть повторение строки один или более раз:
$\alpha \rightarrow \{\beta\}^+$ вместо строчек
\begin{bnf}\begin{eqnarray*}
\alpha &\rightarrow&S\\
S &\rightarrow& \beta S \\
S &\rightarrow& \beta
\end{eqnarray*}\end{bnf}
\vspace{-0.3cm}

Эти два типа повторения легко выражаются один через другой: как $\{\alpha\}^+$ можно
представить как $\alpha\{\alpha\}^*$, так и $\{\alpha\}^*$ --- как $\varepsilon | \{\alpha\}^+$.

\section{Иерархия Хомского}

\begin{definition}
Назовем грамматику неукорачивающей, если все правила в этой
грамматике имеют в левой части не больше символов, чем
в соответствующей правой части.
Грамматика также может содержать правило вида $S \rightarrow \varepsilon$, но только
если нетерминал $S$ не содержится в правых частях правил.
\end{definition}

\begin{definition}
Назовем грамматику бесконтекстной (контекстно-свободной), если все правила в этой
грамматике имеют в левой части в точности один нетерминальный символ и ничего, кроме
него.
\end{definition}

\begin{definition}
Назовем грамматику построенной по регулярному выражению, если:
\begin{itemize}
\item Алфавит нетерминальных символов состоит в точности из одного символа
\item Грамматика имеет единственное правило, левая часть которого --- нетерминальный
символ, а правая состоит только из терминальных символов. Также, в правой части
разрешено использовать сокращения записи (операции <<альтернатива>>, 
<<необязательная часть>> и <<повторение>>).
\end{itemize}
\end{definition}

\begin{definition}
Будем говорить, что язык --- неукорачивающий (бесконтекстный, автоматный), если
он может быть задан соответствующей грамматикой. 
\end{definition}

\begin{definition}Иерархия Хомского имеет 4 уровня:

\vspace{0.3cm}

\begin{tabular}{ll}
Уровень в иерархии&Тип грамматики\\
\hline
0 & Грамматика общего вида\\
1 & Неукорачивающая\\
2 & Бесконтекстная\\
3 & Построенная по регулярному выражению
\end{tabular}
\end{definition}

Легко заметить, что если грамматика (язык) принадлежит уровню $k$ иерархии Хомского, 
то он принадлежит и всем уровням, меньшим $k$.

\section{Регулярные выражения и конечные автоматы}

\begin{definition}
Конечным автоматом мы назовем совокупность:
\begin{itemize}                                         
\item двух алфавитов --- алфавита терминальных символов $A_T$ и алфавита состояний $A_C$;
\item таблицы переходов, сопоставляющей паре символов --- терминальному и состоянию --- некоторое
новое состояние: $T: A_T\times A_C \rightarrow A_C$;
\item начального состояния и множества допускающих состояний.
\end{itemize}
\end{definition}

\begin{definition}
Шаг применения конечного автомата. Если автомат находится в некотором состоянии
$s \in A_C$, то результатом применения автомата к некоторому символу $a \in A_T$
будет новое состояние $T[s,a]$.
\end{definition}

\begin{definition}
Будем говорить, что автомат допускает некоторую строку, если последовательное применение
автомата ко всем символам из строки в порядке их записи в слове приводит автомат
из начального в допускающее состояние.
\end{definition}

\begin{definition}
Будем говорить, что автомат задаёт язык, если он допускает те и только те слова, которые
принадлежат языку.
\end{definition}

\subsection{Недетерминированные конечные автоматы}

Введем альтернативный способ изображения конечных автоматов --- в виде графа.
Будем сопоставлять состояниям автомата точки, а клеткам таблицы переходов --- дуги.
Допускающие состояния будем обозначать двойным кружком, начальное состояние --- входящей стрелкой.
Если дуги для символа для какого-то состояния не указано, то появление такого символа ведёт к недопуску 
строки.

Пример задания одного и того же автомата с помощью таблицы и с помощью графа:
\vspace{3mm}

\begin{tabular}{cc}

\begin{minipage}{5cm}
\begin{tabular}{c|cc}
& $a$ & $b$\\
\hline
$S_0$ & $S_1$ & $S_0$\\
$S_1$ & $S_2$ & $S_0$\\
$S_2$ & $S_2$ & $S_3$\\
$S_3^*$ & $S_3$ & $S_3$\\

\end{tabular}

\end{minipage}

&

\begin{minipage}{8cm}
\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{vertex}=[circle,draw,text=black]

  \node[vertex]   (A) {$S_0$};
  \node[vertex]   (B) [right of=A] {$S_1$};
  \node[vertex]   (C) [right of=B] {$S_2$};
  \node[vertex,double]   (D) [right of=C] {$S_3$};

  \draw [<-] (A) to node[auto] {} ++ (-1,0);
  \path (A) edge              node {a} (B)
            edge [loop above] node {b} (A)
        (B) edge [bend right] node[swap] {b} (A)
            edge              node {a} (C)
        (C) edge              node {b} (D)
	    edge [loop above] node {a} (C)
        (D) edge [loop above] node {a,b} (D);
\end{tikzpicture}

\end{minipage}

\end{tabular}


\begin{definition}
Недетерминированный конечный автомат --- это конечный автомат, в котором в каждой клетке
таблицы переходов записано не одно состояние, а множество состояний. То есть, функция 
переходов задаётся иначе: $T: A_T\times A_C \rightarrow 2^{A_C}$.
\end{definition}

\begin{definition}
Мы будем говорить, что недетерминированный конечный автомат допускает строку, если
на каждом шаге применения автомата к символам входной строки (то есть, на символе
$t \in A_T$ и в состоянии $s \in A_C$) найдётся такой переход (из множества допустимых 
переходов $T[t,s]$), что после последнего шага автомата он окажется в допускающем
состоянии.
\end{definition}

То же самое можно выразить несколько парадоксальной фразой: недетерминированный автомат 
на каждом шагу <<угадывает>>, какой из вариантов перехода выбрать, чтобы достигнуть 
допускающего состояния. 

\begin{definition}
Недетерминированный конечный автомат с эпсилон-переходами --- 
конечный автомат, в котором к алфавиту терминальных символов добавлен <<пустой>> символ
$\varepsilon$, не встречающийся во входной строке.
\end{definition}

\begin{definition}
Назовём состояние $r$ $\varepsilon$-достижимым из состояния $s$, если существует последовательность
$\varepsilon$-переходов, позволяющая достичь $r$ из $s$.
\end{definition}

\begin{definition}
Мы будем говорить, что недетерминированный конечный автомат с $\varepsilon$-переходами 
допускает строку, если на каждом шаге применения автомата к символам входной строки 
(то есть, на символе $t \in A_T$ и в состоянии $s \in A_C$) найдётся такое 
$\varepsilon$-достижимое состояние $r$ и такой переход из него (из множества допустимых 
переходов $T[t,r]$), что после последнего шага автомата допускающее состояние окажется
$\varepsilon$-достижимо.
\end{definition}

Иными словами, недетерминированный конечный автомат с $\varepsilon$-переходами может в
любой момент самопроизвольно выполнить любое количество $\varepsilon$-переходов,
если это ведёт к цели (к допуску строчки).

Несложно показать, что по любому недетерминированному автомату с $\varepsilon$-переходами 
можно построить детерминированный, задающий тот же язык (для этого надо рассмотреть автомат 
с алфавитом состояний $2^{A_C}$). Поэтому классы языков, задаваемые и детерминированными и
недетерминированными автоматами, одинаковы. Однако, в разных задачах удобен разный тип
автоматов. 

\subsection{Соответствие регулярных выражений конечным автоматам}

Известно, что грамматики, построенные по регулярным выражениям, задают в точности то же 
множество языков, что и конечные автоматы.
Мы можем это показать, например, двумя включениями: показав, как заданный грамматикой язык
задать конечным автоматом --- и как язык, заданный конечным автоматом, задать с помощью 
грамматики, построенной по регулярному выражению.

Мы покажем, как преобразовать регулярное выражение в недетерминированный конечный автомат, задающий 
тот же язык. 
Обратное преобразование также можно произвести, но оно останется за рамками данного курса.

В регулярном выражении возможны 4 типа конструкций: литерал (терминальный символ),
конкатенация ($\alpha\beta$), альтернатива ($\alpha|\beta$)
и повторение ($\{\alpha\}^+$). Нам достаточно предложить способ построения автомата для
литералов и способы построения более сложных автоматов на основе уже имеющихся в остальных 
трёх типах конструкций. 

\begin{enumerate}
\item Литерал. Автомат, допускающий символ $x$ (и только его), выглядит так:

\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{vertex}=[circle,draw,text=black]

  \node[vertex]   (A) {$S_0$};
  \node[vertex,double]   (B) [right of=A] {$S_1$};

  \draw [<-] (A) to node[auto] {} ++ (-1,0);
  \path (A) edge              node {$x$} (B);
\end{tikzpicture}

\item Конкатенация. Пусть даны два автомата, задающие $\alpha$ и $\beta$ 
(они схематично изображены квадратами на графе).
Тогда автоматом, задающим $\alpha\beta$, будет

\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{vertex}=[draw,text=black]

  \node[vertex,circle] (S) {$S_0$};
  \node[vertex,rectangle,minimum height=1 cm, minimum width = 1cm]   (A) [right of=S] {$\alpha$};
  \node[vertex,rectangle,minimum height=1 cm, minimum width = 1cm]   (B) [right of=A] {$\beta$};
  \node[vertex,double,circle] (E) [right of=B] {$S_1$};

  \draw [<-] (S) to node[auto] {} ++ (-1,0);
  \path (S) edge   node  {$\varepsilon$}(A)
        (A) edge   node  {$\varepsilon$}(B)
        (B) edge   node  {$\varepsilon$}(E);
\end{tikzpicture}

\item Альтернатива. Пусть даны два автомата, задающие $\alpha$ и $\beta$.
Тогда автоматом, задающим $\alpha|\beta$, будет

\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{vertex}=[draw,text=black]

  \node[vertex,circle] (S) {$S_0$};
  \node[vertex,rectangle,minimum height=1 cm, minimum width = 1cm]   (A) at (2,1) {$\alpha$};
  \node[vertex,rectangle,minimum height=1 cm, minimum width = 1cm]   (B) at (2,-1) {$\beta$};
  \node[vertex,double,circle] (E) at (4,0) {$S_1$};

  \draw [<-] (S) to node[auto] {} ++ (-1,0);
  \path (S) edge   node  {$\varepsilon$}(A)
        (S) edge   node  {$\varepsilon$}(B)
        (A) edge   node  {$\varepsilon$}(E)
        (B) edge   node  {$\varepsilon$}(E);
\end{tikzpicture}

\item Повторение. Пусть дан автомат, задающий $\alpha$. Тогда автоматом, задающим $\{\alpha\}^+$, будет

\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{vertex}=[draw,text=black]

  \node[vertex,circle] (S) {$S_0$};
  \node[vertex,rectangle,minimum height=1 cm, minimum width = 1cm]   (A) [right of=S] {$\alpha$};
  \node[vertex,double,circle] (E) [right of=A] {$S_1$};

  \draw [<-] (S) to node[auto] {} ++ (-1,0);
  \path (S) edge   node  {$\varepsilon$}(A)
        (E) edge  [bend right=40] node [swap] {$\varepsilon$}(S)
        (A) edge   node  {$\varepsilon$}(E);
\end{tikzpicture}

\end{enumerate}

При помощи этих четырёх примитивов можно последовательно построить автомат, соответствующий любому
регулярному выражению.

\end{document}
