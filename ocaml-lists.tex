\section{Списки}

\subsection{Определение}

Слово список всем хорошо знакомо: список дел, список класса, список оценок.
В программировании так называют структуру данных, позволяющую хранить 
упорядоченный набор значений, при этом важно, что мы умеем быстро добавлять
элемент в начало списка и быстро убирать начальный элемент. 

Определение, данное выше, весьма размытое, но с помощью Окамля мы можем его 
формализовать.

Списком назовём алгебраический тип, заданный следующим образом:
\begin{verbatim}
type 'a list = Nil | Cons of 'a * ('a list)
\end{verbatim}
Напомним, что значит эта запись: список есть либо константа \verb!Nil!, 
либо конструктор типа \verb!Cons!, имеющий аргументом пару из значения и 
списка.

Поясним, почему \verb!Cons (3, Cons (5, Nil))! --- список. Начнём с
\verb!Nil!, который является списком по первому правилу из определения.
Раз так, значит, \verb!Cons (5, Nil)! --- тоже список,
поскольку у \verb!Cons! аргументом как раз и является пара из значения 
(\verb!5!) и списка (\verb!Nil!). А раз \verb!Cons (5, Nil)! --- список,
то и всё выражение --- тоже список.

Поскольку списки --- одни из основных конструкций Окамля, то для них
предопределён особый синтаксис: вместо \verb!Nil! используются 
квадратные скобки (\verb![]!),
а вместо \verb!Cons! --- двойное двоеточие (\verb!::!). Таким образом, 
\verb!Cons (3, Cons (5, Nil))! записывается как \verb!3 :: (5 :: [])!.

Также, список можно задавать явным перечислением значений в квадратных
скобках через точку с запятой: \verb![3;5]!.

Ещё определим несколько полезных слов. \emph{Пустой} список --- список, 
состоящий только из \verb![]!, т.е. список, не содержащий никаких значений.
В противоположность ему, любой непустой список 
$a_1 \verb!::! (a_2 \verb!::! \dots \verb!::! (a_n \verb!::! \verb![]!))$
можно разбить на \emph{голову} и \emph{хвост}: голова --- это $a_1$, а хвост --- это
остающийся после удаления головы список $a_2 \verb!::! \dots \verb!::! (a_n \verb!::! \verb![]!)$.
Или иначе: если рассмотреть конструктор типа \verb!::!, то левый его аргумент ---
это голова, а правый --- хвост (\emph{голова} \verb!::! \emph{хвост}).

\subsection{Доступ к элементам списка}

Как мы уже проходили, доступ к элементам алгебраического типа в первую очередь
осуществляется с помощью сопоставления с образцом и конструкции \verb!match!, 
и списки --- не исключение.

Классический, самый прямой, вариант применения этой конструкции покажет функция 
вычисления длины списка:

\begin{verbatim}
let rec length l = match l with
    [] -> 0
  | h::t -> 1 + length t;;
\end{verbatim}

Два конструктора в определении списка --- значит, два варианта в \verb!match!.
Первый случай --- когда список пуст, второй --- когда список собран из некоторых
головы и . Самой по себе головой мы не интересуемся, ведь, чтобы посчитать
количество элементов в списке, вникать в сами эти элементы не обязательно.
Поэтому значение \verb!h! не указано справа от стрелки, только слева --- а справа
мы всегда прибавляем 1 к длине хвоста. 

В самом деле: пусть есть непустой список \verb!l!. Раз он непустой, то он образован
конструктором <<двойное двоеточие>> из какого-то элемента \verb!h! и какого-то ещё
списка \verb!t!: \verb!l = h::t!. Понятно, что длина \verb!t! на один элемент
меньше, чем длина всего списка. 

\subsection{Пример: красивая печать списка}

Всё, что дальше будет излагаться про списки, ничего принципиально нового не содержит:
это будут примеры на использование уже рассказанных выше конструкций. Однако, 
данные примеры могут быть поучительны.

В этом подразделе рассмотрим задачу печати список целых чисел. Мы можем сделать это
в целом следуя идее, использованной при вычислении длины.

\begin{verbatim}
let rec print_int_list l = match l with
    [] -> ()
  | h::t -> print_int h; print_int_list t;;
\end{verbatim}

Отличия от функции \verb!length! здесь только в том, что мы не возвращаем длину
списка, а печатаем его --- возвращаем же мы \verb!()!. Напомним, что данное 
значение принадлежит типу \verb!unit! и используется там, где формально указать
значение нужно, а фактически написать нам нечего --- ведь весь смысл данной
функции напечатать текст на экране; новых значений с её помощью мы не создаём.

Итак --- в случае пустого списка мы возвращаем <<ничего>> --- то есть \verb!()!, а в случае
наличия головы и хвоста печатаем голову, после чего рекурсивно вызываем печать
для хвоста.

Однако, вызов \verb!print_int_list [1;2;3]! выдаст нам \verb!123! --- напечатает
числа без пробелов. Это можно исправить, добавив разделителей между числами, например, так:

\begin{verbatim}
let rec print_int_list l = match l with
    [] -> ()
  | h::t -> print_int h; print_string ","; print_int_list t;;
\end{verbatim}

Однако, результат не станет идеальным: мы получим \verb!1,2,3,!. Каша из цифр
исчезла, но появилась заключительная запятая, которая будет сбивать с толку.
Причина её появления очевидна: мы \emph{всегда} печатаем запятую после числа,
однако, в красивой записи запятая разделяет два числа, и за последним числом 
не нужна. Поэтому нам нужно две версии печати числа: с запятой в конце или без неё.

Идея, как мы могли бы отличить эти два случая, проста --- у последнего двойного двоеточия
списка пустой хвост: $a_1 \verb!::! (a_2 \verb!::! \dots \verb!::! (a_n \verb!::! \verb![]!))$.
Иными словами, когда последнее число списка $a_n$ окажется в переменной \verb!h! образца,
в переменной \verb!t! окажется пустой список. Это наблюдение приводит к следующей 
программе:

\begin{verbatim}
let rec print_int_list l = match l with
    [] -> ()
  | h::[] -> print_int h
  | h::t -> print_int h; print_string ","; print_int_list t;;
\end{verbatim}

Обратите внимание, что мы вставили вариант печати последнего элемента списка перед 
общим случаем. Конструкция \verb!match! перебирает варианты строго сверху вниз,
и выбирает первый подходящий образец. Если бы мы поставили обработку последнего
элемента ниже общего случая, соответствующий код никогда бы не вызывался.

Последний штрих: данная функция печатает только целочисленные списки.
А что делать, если нам нужно печатать списки других типов, например, состоящие из строк?
Окамль в общем случае не знает, как печатать значение произовольного типа. Для этой цели
давайте функции печати списка передавать функцию печати элемента:

\begin{verbatim}
let rec print_list f l = match l with
    [] -> ()
  | h::[] -> f h
  | h::t -> f h; print_string ","; print_list f t;;
\end{verbatim}

Вызывать теперь её нужно, правда, чуть хитрее:

\begin{verbatim}
print_list print_int [1;2;3]
\end{verbatim}

Функция \verb!print_list! теперь берёт на вход два параметра, и первый --- это функция
\verb!print_int!, которая печатает элементы. Если нам в другой ситуации потребуется
печать списка строк, мы без труда сделаем это: \verb!print_list print_string ["a";"b";"c"]!.

\subsection{Пример: соединение двух списков}

Определим функцию \verb!append!, соединяющую два списка --- скажем, чтобы из списков 
\verb![1;2]! и \verb![3;4]! получался бы список \verb![1;2;3;4]!. Главная сложность здесь ---
увидеть, как организовать рекурсию.

Возьмём первый список и разберём возможные случаи. Если первый список пуст, 
результатом функции, очевидно, будет второй: добавление пустого списка не изменяет 
результат. Если же первый список содержит голову $a_1$ и хвост $[a_2; \dots; a_n]$, 
мы можем рекурсивно соединить хвост со вторым списком, а затем добавить голову 
к результату: 
$$append [a_1; a_2; \dots a_n] [b_1; b_2; \dots b_n] = append (a_1 :: [a_2; \dots a_n]) [b_1; \dots; b_n] = $$
$$a_1 :: append [a_2; \dots a_n] [b_1; b_2; \dots b_n]$$
Ведь всё равно элемент $a_1$ должен быть первым в итоговом списке --- поэтому
мы его можем сразу от первого списка отцепить, и прицепить уже к результату 
рекурсивного вызова.

Это даёт нам следующую программу:

\begin{verbatim}
let rec append a b = match a with
    [] -> b
  | h::t -> h::(append t b)
\end{verbatim}

Поскольку данная операция очень часто нужна при работе со списками, она
встроена в язык и у неё специальное имя --- символ <<коммерческое „эт“>>
(\verb!@!), он же неформально называется <<собака>>. 
Соответственно, следующее странное на первый взгляд равенство в Окамле 
вполне осмысленно: 
\verb![1;2] @ [3;4] = [1;2;3;4]!

\subsection{Пример: разворот списка}

И следующий пример, который мы разберём --- функция разворота, делающая из списка $[a_1;a_2;\dots;a_n]$
список $[a_n;a_{n-1};\dots;a_2;a_1]$.

Прямолинейное решение, \verb!match! по аргументу, вполне сработает.
Для пустого списка его разворот также пуст, для непустого --- развернём хвост, а голову списка
присоединим к концу:

\begin{verbatim}
let rec reverse l = match l with
    [] -> []
  | h::t -> reverse t @ [h]
\end{verbatim}

Сразу обращаем внимание, что код \verb!h::t -> reverse t :: h! был бы 
некорректен. Напомним, что двойное двоеточие \emph{всегда} требует слева элемент (голову),
справа список (хвост). В данном же случае получается, что слева указан хвост, а справа --- голова.
Это неизбежно приведёт к ошибке компиляции.

Также, возможно, кого-то озадачит код \verb![h]! --- но это всего лишь список, содержащий
\verb!h! в качестве единственного своего элемента. Для Окамля нет никакой разницы между
записями \verb![5]!, \verb![1+1*4]! или даже \verb!let x = 5 in [x]!, внутри квадратных 
скобок может стоять любое выражение.

Однако, можно предложить и другое решение:

\begin{verbatim}
let rec revh l a = match l with
    [] -> a
  | h::t -> revh t (h::a);;

let reverse l = revh l [];;
\end{verbatim}

Проследим за тем, как данный код развернёт трёхэлементный список \verb![2;3;4]!
(мы напишем только цепочку равенств, более подробный анализ исполнения кода оставим
читателю):

\begin{verbatim}
revh [2;3;4] [] = revh [3;4] [2] = revh [4] [3;2] = revh [] [4;3;2] = [4;3;2]
\end{verbatim}

Функция \verb!rehv! на каждом рекурсивном вызове перекидывает
по элементу из исходного списка в итоговый, пока не развернёт его целиком. 
