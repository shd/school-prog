\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{bnf}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage[margin=2cm]{geometry}
\usetikzlibrary{arrows,backgrounds,patterns,matrix,shapes,fit,calc,shadows,plotmarks}
\usepackage{enumerate}
\usepackage{proof}
\usepackage{amsthm}
\begin{document}

\theoremstyle{definition}
\newtheorem{definition}{Определение}[section]

\title{Введение в git и github}
\author{Д.Г. Штукенберг, ЛНМО}

\maketitle

\section{Системы контроля версий}

Когда работа над проектом занимает длительное время и (или) требует
многих участников, возникает вопрос об удобном и надёжном хранилище 
для файлов. Такие задачи как синхронизация изменений, хранение 
истории изменений, различных версий файлов --- они требуют больших
усилий и внимательности, и всё равно файлы периодически могут быть
утеряны или перепутаны. 

Для облегчения работы над такими проектами были разработы системы
контроля версий. Один из самых ранних примеров --- система CVS. 
Мы же будем пользоваться системой
Git --- пожалуй, самой широко распространённой системой контроля версий
на данный момент. Помимо распространённости, в её пользу говорит 
наличие бесплатных серверов, на которых можно бесплатно разместить свои
проекты --- Github и Bitbucket.

\section{Основные понятия}

Главная идея систем контроля версий: они хранят не сами файлы проекта,
а их изменения. Это позволяет с небольшими затратами восстановить любое
состояние вашего проекта на любой момент времени.
Если вы добавили, изменили или удалили какие-то файлы, вы информируете
систему о вашем действии --- и по этой информации можно восстановить
как самое новое состояние проекта, так и предыдущее, можно выяснить,
что изменилось между несколькими версиями.

Хранилище информации по проекту в git называется \emph{репозиторием}.
Репозиторий хранит последовательность \emph{коммитов}:
изменений проекта, состоящих из каких-то добавлений, изменений и 
удалений файлов. Коммит не разбивается на более мелкие: либо мы целиком 
применяем содержащиеся в нём изменения к проекту, либо мы целиком от 
них отказываемся. При этом сам по себе коммит может содержать множество
изменений в различных файлах.

Поясним данную идею на примере переименования переменной:
представим, что в проекте из 34 файлов мы переименовали функцию
\verb!weird_function!, назвав её \verb!strange_function!.
Если изменение будет произведено только в части файлов, а в ещё
12 файлах название функции осталось старым, мы получим некомпилирующюуся
программу. Поэтому всё переименование, все изменения во все
34 файла имеет смысл помещать в один коммит. 

Git --- распределённая система, у неё нет центрального сервера, где
лежат все файлы проекта, каждая локальная копия проекта содержит
весь репозиторий. 

\section{Порядок работы}

Ниже приведён перечень шагов, необходимый для создания и работы
с проектом под управлением git. 
Если репозиторий создаётся только на локальном компьютере,
и не предполагается, что он будет доступен извне,
первый шаг (создание репозитория на хосте) можно пропустить.

\subsection{Создание репозитория на хосте}

Данные инструкции даны в предположении,
что репозиторий будет храниться (\emph{хоститься}) 
на сайте \url{https://github.com}.
Подобным же образом его можно завести на сайте 
\url{https://bitbucket.com}. 

\begin{enumerate}
\item Зарегистрируйтесь на сайте \url{https://github.com/},
либо войдите в свой аккаунт, если вы регистрировались ранее.

\item Выберите пункт \verb!Start a project! (как вариант:
\verb!New repository! из меню вверху экрана).

\item Укажите имя для репозитория.

\item Укажите права доступа (рекомендация --- оставьте \verb!public!).

\item Нажмите кнопку \verb!Create a repository!
\end{enumerate}

\subsection{Создание локального репозитория}

Чтобы созданный на хосте репозиторий был бы доступен на локальном
компьютере, используйте команду \verb!git clone!. Ей аргументом
передаётся https-адрес репозитория, который появляется на экране
(на домашней странице проекта) сразу после его создания.

\begin{verbatim}
git clone https://github.com/shd/test-project.git
\end{verbatim}

Эта команда создаст подкаталог для вашего проекта и создаст репозиторий,
аналогичный тому, что лежит на хосте. Сразу после создания он
будет, естественно, (практически) пустой. 

Если репозиторий сразу создаётся локально, вместо клонирования
нужно выполнить команду \verb!git init <имя проекта>! --- она
создаст пустой репозиторий, не привязанный ни к какому хосту.

\subsection{Добавление, изменение и удаление файлов}

После создания локального репозитория заходите в каталог с ним,
и работайте. В тот момент, когда вы решите сделать первый коммит ---
добавить к репозиторию первые файлы вашего проекта --- вам потребуется
команда \verb!git add!.

А именно, вам нужно перечислить все файлы, которые вы добавляете,
в аргументах этой команды. Если вы, например, создали файлы 
\verb!alpha.ml! и \verb!beta.ml!, выполните следующую команду:

\begin{verbatim}
git add alpha.ml beta.ml
\end{verbatim}

Также, команда \verb!add! применяется, если вы изменили 
какой-то файл, уже ранее добавленный к репозиторию.

Если вы хотите удалить какой-то файл из репозитория, используйте
\verb!git rm <имя файла>!.

\subsection{Формирование коммита}

Ваши изменения не будут добавлены к репозиторию, пока вы не выполните
(не сформируете) коммит: 

\begin{verbatim}
git commit -m "Commit message"
\end{verbatim}

Данное действие запомнит в репозитории все изменения проекта, о которых
git был уведомлён командами \verb!add! и \verb!rm!.
Сообщение коммита (commit message) обязательно, но его содержание
может быть любым. Сообщение предназначено для вас и ваших товарищей:
желательно, чтобы из него была понятна цель вашего коммита.

Если вы не знаете, что в точности будет включено в коммит, 
напишите команду \verb!git status! --- она укажет, в чём отличие
текущего состояния проекта от последнего состояния из репозитория.

Данная команда напечатает общий список отличий: какие файлы изменены,
добавлены или удалены.
Если вы хотели бы узнать конкретные отличия какого-то файла, используйте
\verb!git diff <имя файла>!.

\subsection{Синхронизация с хостом}

В тот момент, когда вы закончили работу и хотите передать её результаты
на сервер, используйте команду \verb!git push!. После неё все новые
коммиты будут доступны на хосте (если точнее, на том сервере, на котором
укажете --- по умолчанию новые коммиты будут отправлены на тот сервер,
с которого вы склонировали репозиторий).
Например, эту команду можно вызвать после занятий в классе на уроке
информатики для передачи наработанного кода на сервер.

Если же вы хотите скачать локальные изменения на свой компьютер,
используйте \verb!git pull!. Например, эта команда может вами быть
вызвана дома перед выполнением домашнего задания для получения
выполненных на уроке заданий.

Не забывайте эти две команды! Если не выполнить их, то окажется, что
те изменения, которые вы сделали в своём проекте, например, в школе,
останутся там на локальном компьютере --- и не будут вам доступны дома.

\section{Краткий перечень команд работы с git}

\begin{enumerate}
\item Команды для работы с репозиторием в целом.

\begin{enumerate}
\item \verb!git clone <репозиторий>! --- клонировать проект, то есть создать полную
локальную копию репозитория. 
\item \verb!git pull! --- взять свежую версию из исходного репозитория 
(в нашем случае: версию с github) и объединить эту версию с текущей версией на 
локальном компьютере. В случае значительных расхождений git может отказаться от
объединения --- тогда надо пользоваться командой \verb!git merge!.
\item \verb!git push! --- обновить исходный репозиторий (в нашем случае: версию на github),
внести в него изменения, внесённые на локальном компьютере. Если на сервере есть
новые изменения, ещё не учтённые на локальном компьютере, то операция будет отклонена,
и вам потребуется сперва объединить сторонние изменения с локальными при помощи
команд \verb!git pull! и \verb!git merge!, и только потом выложить текущий локальный
репозиторий на github с помощью команды \verb!git push!.
\end{enumerate}

\item Команды для работы с коммитами и отдельными файлами из репозитория
\begin{enumerate}
\item \verb!git add <имя файла>! --- добавляет файл к проекту, если его в проекте нет. 
Если же файл уже в проекте --- уведомляет git о том, что изменения в файле надо запомнить.
\item \verb!git rm <имя файла>! --- удаляет файл из проекта.
\item \verb!git commit -m "<сообщение>"! --- создаёт коммит, учитывая изменения во
всех файлах, указанных в командах \verb!add! и \verb!rm!. Изменения в остальных файлах 
будут проигнорированы.
\item \verb!git status! --- печатает информацию об отличиях файлов на диске
от репозитория. То есть, о том, какие файлы не отслеживаются git, какие добавлены, 
какие удалены, какие изменены.
\item \verb!git diff <имя файла>! --- печатает информацию об отличии указанного файла
от репозитория.
\item \verb!git log [<имя файла>]! --- печатает информацию коммитах,
в которые входил данный файл. Если имя файла не указывает, печатает 
информацию о всех коммитах.
\item \verb!git checkout <имя файла>! --- вернуться к версии файла,
находящейся в репозитории. Все локальные изменения файла, не добавленные
в репозиторий, после выполнения данной команды будут утеряны. 
\end{enumerate}
\end{enumerate}

\end{document}