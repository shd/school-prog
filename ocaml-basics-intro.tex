\setcounter{chapter}{1}

\newcommand\n[1]{\textit{#1}}

\section {Структура программы}
Поскольку мы только учимся, давайте несколько упрощённо скажем, что программа 
на языке Окамль --- это последовательность выражений и описаний,
указываемых через двойное двоеточие (;;). Или то же самое зададим грамматикой:

\begin{bnf}\begin{eqnarray*}
\n{<программа>} &::=& ( \n{<описание>} | \n{<выражение>} ) \s{;;} [ \n{<программа>} ]
\end{eqnarray*}\end{bnf}

\subsection{Выражение}

Выражения как идея вам должны быть хорошо знакомы.
Например, вы наверняка умеете строить арифметические выражения с помощью арифметических действий.
Выражение $2 + 2$ имеет в Окамле такой же смысл, как и в арифметике.

Однако, начнём мы с немного иных выражений. Рассмотрим такую программу:

\begin{verbatim}
print_string "Здравствуй, мир!";;
\end{verbatim}

Данная программа состоит из единственного вызова функции \s{print\_string}.
При запуске она печатает текст \s{Здравствуй, мир!}, после чего заканчивает работу. 
Давайте напишем что-нибудь еще:

\begin{verbatim}
print_string "Здравствуй, ";;
print_string "мир!";;
\end{verbatim}

Эта программа делает в точности то же самое, но
устроена сложнее: в ней два выражения, каждое из которых
печатает свой кусок текста.

%Данное выражение - это вызов функции \s{print\_string}, получающей один аргумент,
%текстовую строчку. Функция печатает строчку на экране и заканчивает работу.

\subsection{Описание}

Идея описаний для вас тоже не должна быть новой. Описания подобны словам
<<обозначим за $v$ скорость пешехода>>, часто встречающимся в решениях задач
по физике и математике.

Рассмотрим такую программу:

\begin{verbatim}
let str = "Здравствуй, мир!";;
print_string str;;\end{verbatim}

В данной программе в первой строке создается константа \s{str}, 
содержащая строчку \s{"Здравствуй мир!"} (иными словами, это описание 
константы \s{str}), которая затем печатается в выражении во второй строке. 

Раз это константа, то ее можно использовать сколько угодно раз:
\begin{verbatim}
let str = "Здравствуй, мир!";;
print_string str;;
print_string str;;
\end{verbatim}
Данная программа будет печатать строчку два раза.

Константу можно переопределить:
\begin{verbatim}
let str = "Здравствуй, мир!";;
print_string str;;
let str = "Привет, мир!";;
print_string str;;
\end{verbatim}
При этом старое значение константы теряется. Данная программа 
напечатает следующий текст:
\begin{verbatim}
Здравствуй, мир!Привет, мир!
\end{verbatim}

Имена (или, более точное слово, \emph{идентификаторы}) констант строятся по
следующим приавилам:
\begin{bnf}\begin{eqnarray*}
\n{<идентификатор>}    &::=& \n{<начальный символ>} \{\n{<символ>}\}*\\
\n{<начальный символ>} &::=& \s{a}..\s{z} | \s{\_}\\
\n{<символ>}           &::=& \s{a}..\s{z} | \s{A}..\s{Z} | \s{0}..\s{9} | \s{\_} | \s{'}
\end{eqnarray*}\end{bnf}

Таким образом, идентификаторы \s{fAAA9\_'} и \s{\_\_\_} вполне допустимы, тогда как
\s{0ffa}, \s{'abcd}, \s{ABCD} не являются допустимыми идентификаторами констант.

Надо отметить, что имя функции \s{print\_string} само является идентификатором
константы, только константы не строкового типа, а функционального.

\subsection{Пробелы, переводы строки, комментарии}

Для компилятора Окамля существенно, чтобы два идентификатора 
отделялись всегда пробелами. Также, не смотря на то, что синтаксис языка не 
требует указания пробела между знаками операций и идентификаторами
(скажем, мы можем написать \s{let x="мир";;}, мы можем их разделить
их пробелом, если это нам кажется правильным: \s{let x = "мир" ;;}
Везде же, где может/должен находиться хотя бы один 
пробел, вместе с ним (или вместо него) может также находиться произвольное 
количество пробелов и/или переводов строк, а также \emph{комментариев}.

Комментарий --- это произвольный текст, ограниченный символами 
\s{(*} и \s{*)}, который не анализируется компилятором. В комментариях
обычно пишут какие-то соображения на естественном языке, 
комментирующие код программы. 

Код программы с комментариями может выглядеть так:

\begin{verbatim}
print_string    "Здравствуй, ";; (* Здравствуй, мир! - это перевод с 
                                    английского классического текста *)
print\_string                    (* hello, world *)
   "мир!"
;;		 
\end{verbatim}

Ещё комментарии используются для временного исключения части кода. Перед
тем, как удалить код из программы, бывает, стоит его <<закомментировать>>. 
Вдруг передумаем удалять?

\section{Элементарные типы данных: числа и строки}

Из школьной программы у вас должно уже сложиться интуитивное понятие типа
значения: скажем, скорость измеряется в километрах в час, а масса ---
в килограммах. При этом ясно, что выражение <<1 км/ч>> + <<5 кг>> 
в общем случае бессмысленно и никакого естественного способа его вычислить 
мы не знаем.

В программировании это интуитивное понятие встречается очень часто, поэтому,
чтобы двигаться дальше, нам потребуется его формализовать. Данная 
формализация несовершенна, но подходит для целей знакомства с
языком Окамль.

\begin{definition}
\emph{Типом данных} называется множество значений. 
\end{definition}

Например, целочисленный тип данных в языке Окамль 
(при работе на 32-разрядном компьютере) составляют все целые 
числа в диапазоне от $-2^{30}$ до $2^{30}-1$.

Тип может иметь имя, для целых чисел в Окамле используется имя \s{int},
для чисел с плавающей точкой --- \s{float}, для строчек --- \s{string}.

\emph{Литералом} некоторого значения мы будем называть его запись
в программе. 
Например, литералом для строчки \s{Здравствуй, мир!} 
будет \s{"Здравствуй, мир!"}.

\subsection{Строки}

Рассмотрим строковые литералы подробнее:
\begin{bnf}\begin{eqnarray*}
\n{<строковый-литерал>} &::=& \s{"{}} \n{<символ>}* \s{"{}} \\
\n{<символ>} &::=& \n{<печатный символ>} | \s{\textbackslash{}} \n{<спецсимвол>}\\
\n{<спецсимвол>} &::=& \s{"{}} | \s{\textbackslash{}} | \s{n}
\end{eqnarray*}\end{bnf}Здесь \n{<печатный символ>} 
--- это любой символ, кроме двойных кавычек (") и обратной косой черты (\textbackslash{}). 

Зачем нужны спецсимволы? Например, чтобы задавать двойные кавычки как часть текста.
Рассмотрим текст \verb!""^""!: следует ли его понимать как соединение двух пустых
строк \verb!("")^("")! или его следует понимать как литерал строки \verb!"^"!?
Иными словами, вторые и третьи кавычки --- это символы строки или ограничители строки?

Чтобы избежать путаницы, в Окамле принято считать, что двойные кавычки всегда ограничивают
строку, а для указания кавычек как символа используется последовательность
из двух символов: обратной косой черты и кавычек (\verb!\"!). Литерал 
\s{"\textbackslash{}"\textbackslash{}\textbackslash{}"} задает строчку 
из кавычки, за которой идет обратная косая черта, а литерал 
\s{"\textbackslash{}\textbackslash{}\textbackslash{}"\textbackslash
{}\textbackslash{}\textbackslash{}""} задает 
строчку \s{\textbackslash{}"\textbackslash{}"}.

Но помимо обычных символов, существуют и другие символы, которые нужно 
иметь возможность
вставлять в строки, но которым не соответствует никакого изображения. 
Нам пока потребуется только один из них --- символ перевода (окончания) 
строки. Всё, что печатается после него, будет печататься
на новой строке. Для его задания служит последовательность 
\s{\textbackslash{}n}. 

Так, программа 
\begin{verbatim}
print_string "Здравствуй,\nмир!";;
\end{verbatim}

напечатает 2 строки:
\begin{verbatim}
Здравствуй,
мир!
\end{verbatim}

\subsection{Целые числа}

Литералы целых чисел задаются следующей грамматикой:

\begin{bnf}\begin{eqnarray*}
\n{<литерал целого числа>} &::=& \{\s{0}..\s{9}\}^+
\end{eqnarray*}\end{bnf}

\begin{example} 
Следующие строчки являются литералами целых чисел:
\begin{center}
\s{2419}\quad\s{71000}\quad\s{001}\quad\s{0}
\end{center}
\end{example}

%Сами целые числа, как уже указывалось, в случае 32-разрядной ОС имеют
%диапазон от $-2^30$ до $2^30-1$, но чтобы задать отрицательное число,
%требуется применить унарную операцию \emph{минус}: так, число \emph{-23}
%может быть записано как $-23$. Хоть эта запись и выглядит неотличимо
%от традиционной записи отрицательного числа, есть ситуации, где эта
%разница будет существенной.

\subsection{Плавающие числа}

К сожалению, в силу своей конечной природы, компьютер не может в точности 
представить вещественное число (которое может иметь бесконечное количество
знаков), поэтому для их представления пользуются некоторым приближением
к этому понятию --- \emph{плавающими числами} (или, более формально, 
\emph{числами с плавающей запятой}). Эти числа представляют из себя 
двоичные дроби ограниченной длины. Естественно, в языках программирования
вместо двоичных дробей пользуются десятичными, что удобнее, но может приводить
к дополнительным потерям точности.

Упрощенный синтаксис литералов чисел с плавающей запятой:
\begin{bnf}\begin{eqnarray*}
\n{<литерал плавающего числа>} &::=& {\{\s{0}..{9}\}^+}.\{\s{0}..\s{9}\}^+ \\
                     &|& {\{\s{0}..\s{9}\}^+}. \\
                     &|& .\{\s{0}..\s{9}\}^+
\end{eqnarray*}\end{bnf}
\begin{example} 
Следующие строчки являются литералами плавающих чисел:
\begin{center}
\s{00024.19}\quad\s{71.000}\quad\s{0.17}\quad\s{147.}\quad\s{.1717}
\end{center}
\end{example}

Как видите, от обычной записи десятичной дроби отличий два:
\begin{itemize}
\item Вместо традиционной запятой в числе используется точка.
\item Помимо основной формы есть сокращенные, когда ноль в целой или дробной
части может быть опущен: числа \s{0.0}, \s{0.} и \s{.0} --- это одно и то 
же число.
\end{itemize}

%Чтобы записать отрицательное число, надо использовать унарную операцию
%\emph{плавающий минус}: \s{-.14.1} --- это $-14.1$.

\subsection{Арифметические выражения}

Как вы, возможно, обратили внимание, литералы для значений каждого типа 
существенно различаются. Если значение в кавычках --- это строка, если
оно состоит только из цифр --- это целое число, если оно содержит точку ---
это плавающее число.
Такое разделение создано намеренно: никакое значение одного элементарного 
типа не может принадлежать какому-то другому элементарному типу.

Арифметические функции для работы с целыми и плавающими
числами также имеют разные имена. Нельзя пользоваться целочисленной
операцией для работы с плавающими числами и наоборот, плавающей операцией
для работы с целыми.
В таблице приводятся обозначения для четырех основных арифметических 
операций и примеры работы с ними.

\begin{tabular}{lccl}\\
\hline
Действие & Целые & Плавающие & Примеры\\
\hline
Сложение & \s{+} & \s{+.} & \s{14+12}\quad\s{14.+.12.}\\
Вычитание & \s{-} & \s{-.} & \s{41-20}\quad\s{.23-.71.}\\
Умножение & \s{*} & \s{*.} & \s{24*90}\quad\s{78.42*.84.0}\\
Деление & \s{/} & \s{/.} & \s{64/16}\quad\s{0.14/.9881.}\\
\hline\\
\end{tabular}

\begin{example}
Такие выражения содержат ошибки:
\begin{center}
\s{24+42.071}\quad\s{5.0*.5}\quad\s{20/.20}
\end{center}
А такие выражения синтаксически корректные:
\begin{center}
\s{24.+.42.071}\quad\s{5*5}\quad\s{20/20}
\end{center}
\end{example}

Точка у арифметических операций для плавающих
чисел --- это часть их имени, как и точка в обозначении соответствующих
литералов. Если вы описываете константу, точки в ее имени \emph{не} ставятся.
Например, в коде ниже три константы для плавающих чисел: \verb!pi!, \verb!diameter!, \verb!area!,
ни при одной из них не указывается точка:
\begin{verbatim}
let pi = 3.1415926;;
let diameter = 4.0;; (* 4 метра *)
let area = pi *. diameter *. diameter /. 4.;; (* вычисляем площадь *)
\end{verbatim}

\section{Условное выражение}

Вернемся к одной из задач: будем решать линейное уравнение вида $a \cdot x + b = c$.
Нетрудно видеть, что это уравнение почти всегда имеет ровно одно решение,
кроме случая, когда $a = 0$. В этом случае, в зависимости от констант $b$ и 
$c$, уравнение либо имеет бесконечно много решений, либо ни одного.

Надо как-то выделить этот случай, поскольку применение классической формулы
$x = (c - b)/a$ даст деление на $0$, что приведет к ошибке выполнения 
программы. В этом нам поможет условное выражение.

\subsection{Булевский тип}

Для начала мы введем новый тип данных --- \emph{булевский (логический, истинностный)} --- 
имеющий два значения \s{false} и \s{true} (\emph{ложь} и \emph{истина} 
соответственно). Данный тип в Окамле имеет идентификатор \s{bool}.

Тип назван так в честь Джорджа Буля --- английского математика, 
предложившего использовать алгебраические методы в логических рассуждениях.
Это ему мы в значительной степени обязаны идеей представлять ложь как $0$,
а истину как $1$.

Для работы с булевскими типами определены несколько операций:

\begin{tabular}{lcl}\\
\hline
Операция & Обозначение & Пример\\
\hline
Логическое <<И>> & \s{\&\&} & \s{true \&\& false}\\
Логическое <<Или>> & \s{{|}|} & \s{false {|}| false}\\
Отрицание & \s{not} & \s{not true}\\
\hline\\
\end{tabular}

\subsection{Условное выражение}

Условное выражение --- это выражение, задаваемое следующей грамматикой:
\begin{bnf}\begin{eqnarray*}
\n{<условное выражение>} &::=& \s{if}\ \n{<условие>}\ \s{then}\ \n{<ветка then>}\ [ \s{else}\ \n{<ветка else>} ]\\
\n{<условие>} &::=& \n{<выражение>}\\
\n{<ветка then>} &::=& \n{<выражение>}\\
\n{<ветка else>} &::=& \n{<выражение>}
\end{eqnarray*}\end{bnf}В том случае, когда ветка else не указана,
предполагается что это сокращение для записи 
\begin{center}
$\s{if} \n{<условие>} \s{then} \n{<ветка then>} \s{else ()}$
\end{center}

Результат вычисления условного выражения зависит от условия.
Если результат вычисления условия --- \s{true}, то результат всего 
выражения --- это результат вычисления ветки then, иначе --- результат 
вычисления ветки else.

Например, результатом выражения ниже будет 3:

\begin{verbatim}
if 2 > 1 then 3 else 44
\end{verbatim}

\subsection{Операции сравнения}

Определим сравнения в Окамле подробнее:

\begin{tabular}{lcl}\\
\hline
Операция & Обозначение & Пример\\
\hline
равно            & \s{=}  & \s{1 = 1}\\
не равно         & \s{<>} & \s{"строка"{} <> "еще одна строка"}\\
больше           & \s{>}  & \s{2 > 1}\\
меньше           & \s{<}  & \s{1.0 < 2.0}\\
больше или равно & \s{>=} & \s{1 >= 1}\\
меньше или равно & \s{<=} & \s{false <= true}\\
\hline\\
\end{tabular}

Все приведенные выше примеры выдают значение \s{true}. Напротив, 
выражения
\begin{center}
\s{1=0}\quad\s{2<>2}\quad\s{"я"{}<"а"}\quad\s{2.0>2.0}\quad\s
{1>=2}\quad\s{true<=false}
\end{center}все имеют значение \s{false}.

Обратите внимание, что операции сравнения, в отличие от арифметических,
берут аргументы произвольного типа. Единственным условием является то, что
тип левого аргумента и тип правого аргумента должен быть одинаков.
Такие операции называют \emph{полиморфными}. 

\subsection{Пример}

Итак, напишем программу, решающую линейное уравнение:

\begin{verbatim}
print_string "x:\n";;
if a <> 0. then 
  print_float ((c -. b) /. a)
else 
  print_string "либо ни одного, либо бесконечно много";;
\end{verbatim}

Но ответ <<либо ни одного, либо бесконечно много>> слишком неопределенный,
ведь мы можем ответить на вопрос точнее.
Добавим второе условное выражение, разделяющее случаи $b = c$ и $b \ne c$.

\begin{verbatim}
print_string "x:\n";;
if a <> 0. then 
  print_float ((c -. b) /. a)
else (if b = c then
  print_string "любое"
else
  print_string "решений нет");;
\end{verbatim}

Обратите внимание на скобки вокруг второго условного выражения. 
С условными выражениями можно обращаться так же, как и с арифметическими, 
в том числе заключать в скобки. 
Впрочем, в данном конкретном случае мы можем написать
это же чуть красивее:

\begin{verbatim}
print_string "x:\n";;
if a <> 0. then 
  print_float ((c -. b) /. a)
else if b = c then
  print_string "любое"
else
  print_string "решений нет";;
\end{verbatim}

%В так написанной программе результатом вычисления обоих условных выражений 
%будет побочный эффект и значение типа \s{unit}. Но все может быть и иначе: 
%в следующем примере вложенное условное выражение имеет тип \s{string}
%и не имеет побочных эффектов.
%
%\begin{verbatim}
%if a = 0. then print_string (if b = c then "любое" else "решений нет")
%          else print_float ((c -. b) /. a);;
%\end{verbatim}

\section{Функции}

Мы уже довольно давно знакомы с функциями (напомним, первая программа 
состояла из вызова функции \s{print\_string}), но только со стороны
пользователя. Сейчас мы научимся функции описывать.

Существует математические определения функции, как отображения, ставящего
в соответствие каждому элементу одного множества (называемого множеством
отправления), ровно один элемент другого множества (называемого множеством
прибытия).

Это определение сохраняет некоторый смысл и в случае функциональных 
языков программирования - скажем, функция \s{sqrt}, вычисляющая квадратный 
корень, действительно очень близка к математическому определению; 
такая функция называется \emph{чистой}. Но существует и отличие. 
В языках программирования возникает понятие \emph{побочного эффекта} ---
любое действие может, помимо 
вычисления требуемого значения, как-то повлиять на остальной мир.

Например, как вы думаете, функция \s{format\_hard\_disk\_drive}, берущая в 
качестве аргумента целое число и возвращающая строчку 
\s{"винчестер отформатирован"} --- действительно ли это только функция из 
множества целых чисел в множество строк? 

Впрочем и другие, менее разрушительные функции, также могут иметь побочный 
эффект. Например, функция печати строки на экране - ценность ее только в 
побочном эффекте. 
Поэтому мы будем придерживаться другого, более утилитарного, взгляда. 
Функция --- это просто фрагмент кода программы. Функция может быть
\emph{вызвана}, то есть ее код может быть исполнен.

\subsection{Определение функций}

Функцию можно \emph{определить} с помощью следующей конструкции:

\begin{bnf}\begin{eqnarray*}
\n{<определение функции>}   &::=&
  \s{let} [\s{rec}] \n{<идентификатор>} \n{параметры} = 
    \n{<выражение>}\s{;;}\\
\n{<параметры>} & ::= & \n{<идентификатор>}^+ | \s{()}
\end{eqnarray*}\end{bnf}

Отличие определения функции от определения константы --- наличие формальных 
параметров, указываемых через пробел после идентификатора функции 
перед знаком равенства. Нетерминал
\n{<идентификатор>} --- это тот же нетерминал, что и в определении констант.

\begin{example}
\begin{verbatim}
let average a b = (a+b)/2;;
\end{verbatim}
\end{example}

Эта функция берет два аргумента и возвращает их полусумму. 
Константы \s{a} и \s{b} называются формальными параметрами --- 
формальными потому, что при вызове функции вместо них подставляются 
фактические параметры:

\begin{verbatim}
print_int (average 3 9);;
\end{verbatim}

Вычисление значения выражения мы можем представить так: вместо букв \s{a} и \s{b}
в описании функции подставляются числа 3 и 9:

\begin{verbatim}
let average 3 9 = (3+9)/2;;
\end{verbatim}
 
Выражение справа от равенства (тело) функции вычисляется и результат (6)
подставляется в место вызова функции:

\begin{verbatim}
print_int (6);;
\end{verbatim}

В тех случаях, когда функция не имеет параметров, мы должны по правилам
языка Окамль указать какой-нибудь фиктивный параметр --- иначе функция
превратится в константу. Обычно такое нужно из-за побочного эффекта
функции, поскольку чистая функция, не зависящая от аргументов --- это
и есть константа.

Существует специальный тип, который используется для указания
фиктивного значения там, где оно нужно - это тип \s{unit}. Он имеет ровно 
одно значение, записываемое как \s{()}.

Для примера покажем, как описать функцию, печатающую приветствие:

\begin{verbatim}
let print_hello () = print_string "Привет!";;
\end{verbatim}

Здесь значение \s{()} исполняет роль формального формального параметра.
Вызов выглядит уже знакомо:

\begin{verbatim}
print_hello ();;
\end{verbatim}

Здесь значение \s{()} исполняет роль формального фактического параметра.

\subsection{Возвращать или печатать?}

Существенным вопросом, касающимся функций, является вопрос о результате
их работы. Предположим, у нас стоит задача написать функцию, вычисляющую
площадь треугольника.

У нас есть 2 варианта:
\begin{verbatim}
let triangle_area1 a h = a *. h /. 2.;;
let triangle_arge2 a h = print_float (a *. h /. 2.);;
\end{verbatim}

Первый вариант функции \emph{возвращает} значение площади. 
Функция \s{triangle\_area1} берет 2 аргумента с плавающей точкой и 
возвращает плавающий результат.
Второй же вариант печатает площадь треугольника на экране --- а в вызвавшее
функцию выражение возвращает значение типа \s{unit}. 

Не смотря на то, что разница между этими вариантами может казаться 
незначительной --- площадь же все равно вычисляется --- тем не менее, 
в чуть более сложных задачах этот вопрос может стать принципиальным.

Дело в том, что значение функции может быть использовано в дальнейших 
вычислениях, и тем самым появляется много дополнительных случаев для 
ее применения. Функция, печатающая вычисленное значение на экране, такой 
возможности лишена. Поэтому везде в задачах, где явно не указано иное, 
предполагается, что от вас требуется написание функции, к которой при 
необходимости прилагается отдельный код, печатающий ее результат:

\begin{verbatim}
let a = read_float ();;
let h = read_float ();;
let triangle_area a h = a *. h /. 2;;
print\_float (triangle_area a h);;
\end{verbatim}
