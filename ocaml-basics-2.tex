\section{Алгебраические типы данных}

Представим, что мы пишем функцию для вычисления корня линейного
уравнения $$a \cdot x + b = 0$$ 
Если $a /ne 0$, то результат функции --- плавающее число $-\frac{b}{a}$.
Однако, функция может вернуть \emph{не только} плавающее число. 
Например, если $a = 0$ и $b = 0$, то решением уравнения будет любое число,
и никакое конкретное число не будет являться полным ответом.
Также, если $a = 0$ и $b \ne 0$, то решений у уравнения нет вообще.

Таким образом, функция может вернуть один из трёх различных вариантов
ответа: <<один корень>> (в этом случае мы уточняем ответ, указывая
этот корень), <<любое плавающее число --- корень>> и <<корни отсутствуют>>. 

Для таких ситуаций --- а также для многих других, когда у значения есть
несколько вариантов, --- в языке Окамль предусмотрены 
\emph{алгебраические типы}, которым и посвящён этот раздел.

\subsection{Определение алгебраического типа данных}

Давайте определим пользовательский тип данных, способный хранить 
корни линейного уравнения.

Мы уже поняли, что корни уравнения --- это один из трёх вариантов:
<<один корень>> (с указанием этого корня), <<любое плавающее число --- корень>> и <<корни отсутствуют>>. 
В Окамле необходимо называть варианты одним словом, начинающимся с большой буквы: 
пусть они называются \verb!One!, \verb!Any! и \verb!None!. Названия были выбраны
произвольно, на основании английских слов, значащих <<один>>, <<любой>> и
<<никакой>> соответственно --- мы могли выбрать любые другие. 
А теперь составим определение типа:

\begin{verbatim}
type roots = One of float | Any | None;;
\end{verbatim}

Тут задано четыре имени: имя типа (\verb!roots!) и три имени \emph{конструкторов типа} ---
вариантов значений (\verb!One!, \verb!Any!, \verb!None!). 

Пара слов об имени типа. Каждый тип имеет своё имя, мы уже знакомы с некоторыми 
(\verb!int!, \verb!string! и т.п.), и алгебраических типов нам тоже, весьма вероятно,
потребуется не один. Чтобы типы различать, им нужно давать уникальные имена.

Обратите внимание на первый вариант: мы потребовали, чтобы с вариантом \verb!One! 
указывалось ещё и число типа \verb!float!.

%Соответственно, если мы желаем указать значение <<единственный корень, равный 1.4>>,
%то теперь можем написать это так: \verb!One 1.4!, а если требуемое значение --- <<корни отсутствуют>> --- 
%то напишем \verb!None!.

Несколько примеров значений:

\begin{verbatim}
let a = One 1.4;; (* Единственный корень, равный 1.4 *)
let b = Any;;     (* Корень — любое плавающее число *)
let c = None;;    (* Корни отсутствуют *)
\end{verbatim}

Теперь мы можем даже привести функцию, вычисляющую решение линейного 
уравнения, и возвращающую его решение через значение алгебраического типа roots.

\begin{verbatim}
type roots = One of float | Any | None;;

let solve a b c = 
  if a <> 0. then One ((c -. b) /. a)
  else if b = c then Any
  else None;;
\end{verbatim}



%Давайте разберём теперь, как определять алгебраические типы в общем виде:
%
%\begin{bnf}\begin{eqnarray*}
%\n{<описание-алгебраического-типа>} &::=& \s{type\ } \n{<имя>} \s{\ =\ }
%      [\s{|}] \n{<вариант>} \left\{\s{|} \n{<вариант>}\right\}^*{}\\
%\n{<вариант>} &::=& \n{<имя-варианта>} \left[ \s{of} \n{<сигнатура>} \right]\\\\
%\n{<сигнатура>} &::=& \n{<имя-типа>}\\
% &|& \n{<сигнатура>} \s{->{}} \{\n{<сигнатура>}\}^+\\
% &|& \s{(} \n{<сигнатура>} \s{)}
%\end{eqnarray*}\end{bnf}

%Заметьте, для того, чтобы параметризовать варианта, надо указать тип параметра. 
%Неформально с типами мы уже хорошо знакомы, но записывать их \emph{сигнатуры}
%(т.е. обозначения) нам пока не доводилось. 

\subsection{Сопоставление с образцом}

Теперь мы умеем создавать значения алгебраических типов, 
надо научиться их использовать. Например, печатать.

С вариантами без параметров можно справиться и с имеющимися конструкциями,
с использованием условного оператора:
\begin{verbatim}if x = Any then print_string "Любое число"\end{verbatim}%
Но как напечатать корень уравнения, который удалось найти, в случае \s{One}?

Для этого существует сопоставление с образцом.

%Вы должны заметить нечто общее между конструкцией \s{match} и Марковским
%Алгорифмом. Их семантика действительно похожа:
%правила перебираются сверху вниз, и как только найдется подходящее ---
%как только аргумент окажется сопоставим с образцом, указанным в левой
%части правила --- так сразу выражение, стоящее справа, вычисляется, и 
%его результат становится результатом всей конструкции.
%Но собственно процесс сопоставления с образцом отличается. 

%Давайте в этом примере разбираться.

Образец --- это одно из следующего:

\begin{enumerate}
\item литерал, например, \verb!23!, \verb!932.4!, \verb!()!, \verb!true!, \verb!"math"!;
\item имя переменной, например, \verb!x!, \verb!v923!, \verb!_!;
\item кортеж (упорядоченная $n$-ка) других образцов: $(p_1, p_2, \dots, p_n)$ --- образец, если $p_1, \dots p_n$ --- образцы;
например, \verb!(23, x)!, \verb!(23, (x, 17))!;
\item конструктор алгебраического типа без параметра, например \verb!None! или \verb!Any!;
\item конструктор алгебраического типа с параметром: $K p$ --- образец, если $K$ --- конструктор, а $p$ --- образец; например, \verb!One x!.
\end{enumerate}

Сопоставление с образцом в Окамле используется в разных конструкциях,
посмотрим, как это работает в \verb!match!.

\subsection{Конструкция \s{match}}

Рассмотрим, скажем, следующий пример:

\begin{verbatim}
match s with
    0 -> print_string "Ноль"
  | x -> print_string "Не ноль, "; print_int x;;
\end{verbatim}

В конструкции \verb!match! слева от стрелки пишут образцы, а справа --- соответствующие
им выражения.
Первый образец (\verb!0!) сопоставится только, если $s = 0$. 
В остальных случаях сопоставится второй образец (\verb!x!), при этом, как и в
конструкции \verb!let!, переменная \verb!x! получит нужное для сопоставления значение.

Теперь мы можем легко написать функцию, печатающую значение типа roots:

\begin{verbatim}
let print_roots v =
  match v with
    Any    -> print_string "Любое число"
  | None   -> print_string "Корней нет"
  | One f  -> print_float f;;
\end{verbatim}

Существует специальный идентификатор для констант, значения которых нас не 
интересуют --- символ подчеркивания (\s{\_}). При сопоставлении это --- 
обычная константа и, например, сопоставление с образцом \s{One \_} 
происходит так же, как и с образцом \s{One f}. Но в случае удачного 
сопоставления значение константе s{\_} не присваивается. Наиболее типичный 
пример использования этой константы выглядит так:

\begin{verbatim}
match v with
  One f -> print_float f              (* печатаем корень *)
| _ -> print_string "Одного корня нет";; (* а здесь все остальные, 
			неинтересные нам случаи *)
\end{verbatim}

В приведенном выше примере мы печатали результат и значение функции нас
не интересовало. Но все может быть и иначе:

\begin{verbatim}
let finite_roots v = (* функция возвращает true, если ее аргумент -
			не более чем конечное количество корней *)
  match v with
    One _ -> true
  | None  -> true
  | Any   -> false;;
\end{verbatim}

